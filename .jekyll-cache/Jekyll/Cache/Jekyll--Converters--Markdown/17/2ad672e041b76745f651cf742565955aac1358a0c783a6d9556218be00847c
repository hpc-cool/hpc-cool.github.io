I"s<p>在安装了几天之后，终于有了 VisualStudio 2019 于是再安装了 dotnet core 3.0 预览版，现在可以来尝试使用 C# 8.0 的新方式</p>

<!--more-->

<!-- CreateTime:2019/11/29 8:41:20 -->

<!-- csdn -->

<p>新的 VisualStudio 界面十分清真，此时可以通过标签找到自己可以创建的项目</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式1.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181212174618459" alt="" /></p>

<p>找到一个简单的控制台项目，创建的界面也很简单</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式0.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181212174552691" alt="" /></p>

<p>虽然界面不错，但是创建项目的速度没有加快，等了很久，终于看到和之前没有多少修改的界面。虽然开始是没有发现添加了什么功能，但是实际作为太阳系最强IDE还是提供了很多好玩的功能，请看<a href="https://blog.lindexi.com/post/VisualStudio-2019-%E6%96%B0%E7%89%B9%E6%80%A7.html">VisualStudio 2019 新特性</a></p>

<p>在按下调试的时候，发现有一些按钮的界面修改，如下一步的按钮</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式2.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F201812121753079" alt="" /></p>

<p>当前，在使用之前需要做一些准备，首先是<a href="https://aka.ms/netcore3download">下载</a> dotnet core 3.0 不然一些功能不能使用。如果官网无法下载，可以到<a href="https://download.csdn.net/download/lindexi_gd/11100712">CSDN</a>下载</p>

<p>右击项目，编辑一下 csproj 文件</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> &lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre></div></div>

<p>右击项目属性，在生成页面选择用最新语言</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式3.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2018121221123464" alt="" /></p>

<p>正式版的 VisualStudio 2019 需要点击开启预览版</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式5.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20194981321503" alt="" /></p>

<h2 id="可空类型">可空类型</h2>

<p>现在可以提示开发者写出可能为空的代码，如 string 默认可以设置为不可空</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">string</span> <span class="n">str</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>以前这样写代码是可以的，但是现在，可以在 csproj 文件里面添加 NullableReferenceTypes 此时就会在设置 string 为空提示</p>

<p>现在的 csproj 需要添加 NullableReferenceTypes 请看下面</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>&lt;Project Sdk="Microsoft.NET.Sdk"&gt;

  &lt;PropertyGroup&gt;
    &lt;OutputType&gt;Exe&lt;/OutputType&gt;
    &lt;TargetFramework&gt;netcoreapp3.0&lt;/TargetFramework&gt;
    &lt;LangVersion&gt;8.0&lt;/LangVersion&gt;
    &lt;NullableReferenceTypes&gt;true&lt;/NullableReferenceTypes&gt;
  &lt;/PropertyGroup&gt;

&lt;/Project&gt;
</code></pre></div></div>

<p>注意：</p>

<p>在VS2019正式版中，使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="n">NullableContextOptions</span><span class="p">&gt;</span><span class="n">enable</span><span class="p">&lt;/</span><span class="n">NullableContextOptions</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>而不是使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="n">NullableReferenceTypes</span><span class="p">&gt;</span><span class="k">true</span><span class="p">&lt;/</span><span class="n">NullableReferenceTypes</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>再次编译一下项目，虽然可以看到项目编译通过，但是可以看到下面的警告</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式4.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20181212211819918" alt="" /></p>

<p>现在对于 string 是不可空的，但是为了兼容以前的代码，没有强制让编译不通过。同时提供了可空的字符串，也就是 <code class="language-plaintext highlighter-rouge">string?</code> 请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">string</span><span class="p">?</span> <span class="n">str</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</code></pre></div></div>

<p>那么原来的 <code class="language-plaintext highlighter-rouge">str[0]</code> 的这些写法需要怎么修改呢？</p>

<p>答案是可以不修改，直接写</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">string</span><span class="p">?</span> <span class="n">str</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">str</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</code></pre></div></div>

<p>但是编译的时候会出现下面的警告</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">warning</span> <span class="n">CS8602</span><span class="p">:</span> <span class="n">Possible</span> <span class="n">dereference</span> <span class="n">of</span> <span class="n">a</span> <span class="k">null</span> <span class="n">reference</span><span class="p">.</span>
</code></pre></div></div>

<p>如果需要在 string 判断为空的时候不使用，可以使用下面的方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">string</span><span class="p">?</span> <span class="n">str</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="n">str</span><span class="p">?[</span><span class="m">0</span><span class="p">];</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
</code></pre></div></div>

<p><a href="https://www.cnblogs.com/zlmdy/p/10656793.html">C#8.0可空引用类型的使用注意要点 - 自来喵的野 - 博客园</a></p>

<h2 id="range">Range</h2>

<p>第二个好玩的是 Range 可以指定使用数组的哪些内容</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"1 lindexi"</span><span class="p">,</span> <span class="s">"2 doubi"</span><span class="p">,</span> <span class="s">"3 csdn"</span> <span class="p">};</span>

            <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">foo</span><span class="p">[</span><span class="m">0.</span><span class="p">.</span><span class="m">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>此时输出从第 0 元素到第 1 元素，不包括第 1 元素的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">1</span> <span class="n">lindexi</span>
</code></pre></div></div>

<p>如果修改为 <code class="language-plaintext highlighter-rouge">foo[0..2]</code> 就会输出</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">1</span> <span class="n">lindexi</span>
<span class="m">2</span> <span class="n">doubi</span>
</code></pre></div></div>

<p>如果需要从第 1 个元素到最后一个元素，可以这样写</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"1 lindexi"</span><span class="p">,</span> <span class="s">"2 doubi"</span><span class="p">,</span> <span class="s">"3 csdn"</span> <span class="p">};</span>

            <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">foo</span><span class="p">[</span><span class="m">1.</span><span class="p">.])</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 2 doubi</span>
            <span class="c1">// 3 csdn</span>
</code></pre></div></div>

<p>如果想要从第 0 个元素输出到倒数第一个元素，不包括倒数第一个元素，可以这样写</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"1 lindexi"</span><span class="p">,</span> <span class="s">"2 doubi"</span><span class="p">,</span> <span class="s">"3 csdn"</span> <span class="p">};</span>

            <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">foo</span><span class="p">[</span><span class="m">1.</span><span class="p">.^</span><span class="m">1</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">// 2 doubi</span>
</code></pre></div></div>

<p>这里加上了 <code class="language-plaintext highlighter-rouge">^</code> 就是表示倒数，使用 <code class="language-plaintext highlighter-rouge">..</code> 分开开始的值和最后一个值</p>

<p>当然 <code class="language-plaintext highlighter-rouge">1..2</code> 这个只是一个语法糖，这是一个 Range 类</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Range</span> <span class="n">range</span> <span class="p">=</span> <span class="m">1.</span><span class="p">.</span><span class="m">2</span><span class="p">;</span>

            <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">foo</span><span class="p">[</span><span class="n">range</span><span class="p">])</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>关于 Range 请看<a href="https://dotnetcoretutorials.com/2018/12/09/range-type-in-c-8/">Range Type in C# 8 - .NET Core Tutorials</a></p>

<p><a href="https://www.cnblogs.com/lwqlun/p/10095821.html">C# 8中的范围类型(Range Type) - LamondLu - 博客园</a></p>

<h2 id="异步的流">异步的流</h2>

<p>可以通过 async 修饰 yield 返回的方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="k">await</span> <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="nf">Foo</span><span class="p">())</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">temp</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">async</span> <span class="n">IAsyncEnumerable</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;</span> <span class="nf">Foo</span><span class="p">()</span>
            <span class="p">{</span>
                <span class="k">foreach</span><span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="k">new</span><span class="p">[]</span> <span class="p">{</span> <span class="s">"1 lindexi"</span><span class="p">,</span> <span class="s">"2 doubi"</span><span class="p">,</span> <span class="s">"3 csdn"</span> <span class="p">})</span>
                <span class="p">{</span>
                    <span class="k">await</span> <span class="n">Task</span><span class="p">.</span><span class="nf">Delay</span><span class="p">(</span><span class="m">100</span><span class="p">);</span>
                    <span class="k">yield</span> <span class="k">return</span> <span class="n">temp</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>这样就可以异步返回，异步返回的优点在于，之前的写法是先等待 Foo 方法运行完成才能做循环，现在是等待 Foo 方法完成一次就运行一次循环。可以更好做协程提高性能。</p>

<h2 id="匹配优化">匹配优化</h2>

<p>虽然在 C# 7.0 对 switch 做了一波优化，但是还是不够，现在可以写出小伙伴认为这不是 C# 的代码了</p>

<p>现在的 switch 支持表达式等方法</p>

<h3 id="switch-expressions">switch expressions</h3>

<p>表达式写起来的代码将会非常简单，如我定义了一个枚举</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">enum</span> <span class="n">Rainbow</span>
        <span class="p">{</span>
            <span class="n">Red</span><span class="p">,</span>
            <span class="n">Orange</span><span class="p">,</span>
            <span class="n">Yellow</span><span class="p">,</span>
            <span class="n">Green</span><span class="p">,</span>
            <span class="n">Blue</span><span class="p">,</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>我需要判断这个枚举输出对应的值，原先的写法会存在大量的 case 和 break 看起来不好看，现在只需要很简单的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">FromRainbow</span><span class="p">(</span><span class="n">Rainbow</span> <span class="n">colorBand</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="n">colorBand</span> <span class="k">switch</span>
        <span class="p">{</span>
            <span class="n">Rainbow</span><span class="p">.</span><span class="n">Red</span>    <span class="p">=&gt;</span> <span class="s">"红"</span><span class="p">,</span>
            <span class="n">Rainbow</span><span class="p">.</span><span class="n">Orange</span> <span class="p">=&gt;</span> <span class="s">"橙"</span><span class="p">,</span>
            <span class="n">Rainbow</span><span class="p">.</span><span class="n">Yellow</span> <span class="p">=&gt;</span> <span class="s">"黄"</span><span class="p">,</span>
            <span class="n">Rainbow</span><span class="p">.</span><span class="n">Green</span>  <span class="p">=&gt;</span> <span class="s">"绿"</span><span class="p">,</span>
            <span class="n">Rainbow</span><span class="p">.</span><span class="n">Blue</span>   <span class="p">=&gt;</span> <span class="s">"蓝"</span><span class="p">,</span>
            <span class="n">_</span>              <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="n">message</span><span class="p">:</span> <span class="s">"invalid enum value"</span><span class="p">,</span> <span class="n">paramName</span><span class="p">:</span> <span class="k">nameof</span><span class="p">(</span><span class="n">colorBand</span><span class="p">)),</span>
        <span class="p">};</span>
</code></pre></div></div>

<p>通过语法糖可以写出清真的代码，上面代码用到了两个科技，第一个是 C# 7.0 的时候的表达式方法体，也就是方法体不使用 <code class="language-plaintext highlighter-rouge">{}</code> 里面写代码，而是通过 <code class="language-plaintext highlighter-rouge">=&gt;</code> 写一个表达式。更多 C# 7.0 请看 <a href="https://blog.lindexi.com/post/C-7.0.html">C# 7.0</a></p>

<p>第二个科技就是简洁的表达式判断</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式6.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20194982040494" alt="" /></p>

<h3 id="property-pattern">property pattern</h3>

<p>属性匹配是一个好用的方法，可以判断一个输入的类里面的某个属性是否符合条件</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">string</span> <span class="n">F</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
    <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">LeafalljurearjehuNerawaljeeyinaryem</span><span class="p">(</span><span class="n">Foo</span> <span class="n">foo</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">str</span> <span class="p">=</span> <span class="n">foo</span> <span class="k">switch</span>
            <span class="p">{</span>
                <span class="p">{</span> <span class="n">F</span><span class="p">:</span> <span class="s">"林德熙"</span> <span class="p">}</span> <span class="p">=&gt;</span> <span class="s">"林德熙是逗比"</span><span class="p">,</span>
                <span class="p">{</span> <span class="n">F</span><span class="p">:</span> <span class="s">"逗比"</span> <span class="p">}</span> <span class="p">=&gt;</span> <span class="s">"逗比"</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
        <span class="p">}</span>    
</code></pre></div></div>

<p>语法就是 类里面的某个属性加上冒号后面就是判断的属性的值</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="err">某个参数</span> <span class="k">switch</span>
            <span class="p">{</span>
                <span class="p">{</span> <span class="err">参数的某个属性</span><span class="p">:</span> <span class="err">用于判断的值</span> <span class="p">}</span> <span class="p">=&gt;</span> <span class="err">表达式</span><span class="p">,</span>
                <span class="p">{</span> <span class="n">F</span><span class="p">:</span> <span class="s">"逗比"</span> <span class="p">}</span> <span class="p">=&gt;</span> <span class="s">"逗比"</span><span class="p">,</span>
            <span class="p">};</span>
</code></pre></div></div>

<p>同样使用下划线表示默认</p>

<h3 id="tuple-patterns">Tuple patterns</h3>

<p>在 C# 7.0 的元组让小伙伴都说好，在 switch 支持组合元组判断，如我写了一个方法传入了两个参数。可以通过下面的方法判断</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">string</span> <span class="n">first</span><span class="p">,</span> <span class="kt">string</span> <span class="n">second</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">str</span> <span class="p">=</span> <span class="p">(</span><span class="n">first</span><span class="p">,</span> <span class="n">second</span><span class="p">)</span> <span class="k">switch</span>
            <span class="p">{</span>
                <span class="p">(</span><span class="s">"lin"</span><span class="p">,</span> <span class="s">"dexi"</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s">"林德熙是逗比"</span><span class="p">,</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="s">"dexi"</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s">"没错，这就是逗比"</span><span class="p">,</span>
                <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s">"不认识"</span><span class="p">,</span>
            <span class="p">};</span>

            <span class="k">return</span> <span class="n">str</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>试试输入的下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Foo</span><span class="p">(</span><span class="s">"lin"</span><span class="p">,</span> <span class="s">"dexi"</span><span class="p">));</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Foo</span><span class="p">(</span><span class="s">"逗比"</span><span class="p">,</span> <span class="s">"dexi"</span><span class="p">));</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Foo</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">));</span>
</code></pre></div></div>

<p>运行的时候可以看到输出</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式7.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20194985342956" alt="" /></p>

<p>如果是一个类能否也隐私转换为元组可以的，现在微软让 C# 和 .NET 的关系没有之前那么紧密，很多功能都是通过只要一个类里面存在某个方法就可以使用的方式</p>

<p>其实这不是从 C# 8.0 才开始的，在开始 await 的时候就是这样，只需要一个类有 GetAwaiter 方法就可以</p>

<p>在 C# 8.0 只要一个类有 Deconstruct 方法就可以隐式转元组请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Point</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Deconstruct</span><span class="p">(</span><span class="k">out</span> <span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="k">out</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>我的 Point 没有继承任何的类，只是写了 Deconstruct 方法，现在我就可以转换了</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Point</span> <span class="n">point</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=</span> <span class="n">point</span><span class="p">;</span>
            <span class="k">return</span> <span class="s">$"</span><span class="p">{</span><span class="n">x</span><span class="p">}</span><span class="s">,</span><span class="p">{</span><span class="n">y</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>通过这个语法糖可以实现 Positional patterns 的方法</p>

<h3 id="positional-patterns">Positional patterns</h3>

<p>还是刚才的 Point 可以直接将他转换判断</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="kt">string</span> <span class="nf">Foo</span><span class="p">(</span><span class="n">Point</span> <span class="n">point</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="n">point</span> <span class="k">switch</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">when</span> <span class="n">x</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">y</span> <span class="p">&gt;</span> <span class="m">0</span> <span class="p">=&gt;</span> <span class="s">"两个值都大于零"</span><span class="p">,</span>
            <span class="kt">var</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="n">when</span> <span class="n">x</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">y</span> <span class="p">&lt;</span> <span class="m">0</span> <span class="p">=&gt;</span> <span class="s">"两个值都小于零"</span><span class="p">,</span>
            <span class="kt">var</span> <span class="p">(</span><span class="n">_</span><span class="p">,</span> <span class="n">_</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="s">"不合法的值"</span><span class="p">,</span>
            <span class="n">_</span> <span class="p">=&gt;</span> <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span><span class="s">"point"</span><span class="p">),</span>
        <span class="p">};</span>
</code></pre></div></div>

<p>这里的默认值有两个，一个是 <code class="language-plaintext highlighter-rouge">var (_, _)</code> 不关注输入的是任何的值，只要在前面代码没有判断成功的，都进来。但是有一个例外的是连一个值都没有，如空就进入了最后的默认值，请看输入</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Foo</span><span class="p">(</span><span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">)));</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Foo</span><span class="p">(</span><span class="k">new</span> <span class="nf">Point</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">)));</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="nf">Foo</span><span class="p">(</span><span class="k">null</span><span class="p">));</span>
</code></pre></div></div>

<p>运行代码会看到输出</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式8.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20194993015484" alt="" /></p>

<h2 id="using-declarations">using declarations</h2>

<p>之前的 using 是需要带花括号的，这样有小伙伴写的代码需要一个直尺才能知道他是写什么，在 C# 8.0 支持不带花括号的 using 作用范围是一个方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">WriteLinesToFile</span><span class="p">(</span><span class="kt">string</span> <span class="n">str</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">using</span> <span class="nn">var</span> <span class="n">file</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">IO</span><span class="p">.</span><span class="nf">StreamWriter</span><span class="p">(</span><span class="s">"lindexi.txt"</span><span class="p">);</span>

            <span class="n">file</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
            <span class="c1">// file 会在这里释放</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>此时有小伙伴吐槽说，原本使用 using 可以做到在花括号之外可以让小伙伴不会使用到using的变量，但是微软的小伙伴说应该是方法尽可能短而不是在长的方法里面使用花括号</p>

<p>在有了局部方法之后，可以将一个非常小的代码放在一个方法里面，于是就可以用上这个科技。但是这个特性如果用不好确实会让本需要释放的变量在后面使用</p>

<h2 id="static-local-functions">Static local functions</h2>

<p>刚才还说到了局部方法，在使用局部方法的时候，默认是可以拿到局部方法之外的方法的变量的，于是就会出现一些闭包问题。同时如果因为使用了闭包，在一些时候的局部方法的方法指针会变化，于是加等事件的时候很难减等，虽然事件这个问题在编译层已经修复了很多，但是还是存在一些例外情况。于是微软就给了一个清真的方法，静态的局部方法。</p>

<p>静态的局部方法是只能使用传入的参数而不能拿到外部方法的局部变量，这个方法能做到固定方法指针同时请代码清真，因为看到一个变量的时候不需要去想是从哪一层方法传的，也不需要关注这个内部方法是什么时候调用。因为如果用到了上一层方法的局部变量，在不同的时候调用局部方法运行的逻辑也会不一样</p>

<p>将一个局部方法修改为静态的很简单，只需要加上 static 就可以</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">Foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">int</span> <span class="n">y</span> <span class="p">=</span> <span class="m">5</span><span class="p">;</span>
            <span class="kt">int</span> <span class="n">x</span> <span class="p">=</span> <span class="m">7</span><span class="p">;</span>
            <span class="k">return</span> <span class="nf">Add</span><span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

            <span class="k">static</span> <span class="kt">int</span> <span class="nf">Add</span><span class="p">(</span><span class="kt">int</span> <span class="n">left</span><span class="p">,</span> <span class="kt">int</span> <span class="n">right</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="n">left</span> <span class="p">+</span> <span class="n">right</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>如果用了静态的局部方法，在局部方法内如果用到了上一层方法的局部方法就会出现提示静态本地函数不能包含对上一层方法的局部变量引用</p>

<!-- ![](image/VisualStudio 2019 尝试使用 C# 80 新的方式/VisualStudio 2019 尝试使用 C# 80 新的方式9.png) -->

<p><img src="http://image.acmx.xyz/lindexi%2F20194994246135" alt="" /></p>

<h2 id="disposable-ref-structs">Disposable ref structs</h2>

<p>刚才也说到了微软让 C# 渐渐独立，只要某个类存在某些方法就可以用到指定的功能。在结构体是因为不能继承任何接口，所以也就无法实现 Dispose 的释放，但是有一些接口用到了不清真的代码需要释放。之前需要手动调用方法，现在可以通过在结构体里面添加 Dispose 的方法通过 using 释放</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">ref</span> <span class="k">struct</span> <span class="nc">Point</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">X</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Y</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="nf">Point</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">,</span> <span class="kt">int</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Y</span><span class="p">)</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">);</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>对于引用的结构体，详细请看<a href="https://blog.lindexi.com/post/C-7.0.html">C# 7.0</a> 可以添加一个 Dispose 方法，不需要继承任何接口。所以现在的面试题或笔试题就需要更改了，如果要使用 using 释放需要继承什么接口，答案是可以不需要继承接口</p>

<p>释放这个 Point 可以通过 using 的方法，这样就和一个类继承了可释放是相同的</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Point</span> <span class="n">point</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Point</span><span class="p">();</span>
            <span class="k">using</span> <span class="p">(</span><span class="n">point</span><span class="p">)</span>
            <span class="p">{</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>更多请看 <a href="https://blogs.msdn.microsoft.com/dotnet/2018/11/12/building-c-8-0/">Building C# 8.0</a></p>

<p>参见：<a href="https://blogs.msdn.microsoft.com/dotnet/2018/12/05/take-c-8-0-for-a-spin/">Take C# 8.0 for a spin</a></p>

<p><a href="https://www.cnblogs.com/waku/p/10094691.html">[翻译]初试C# 8.0 - WAKU - 博客园</a></p>

<p><a href="https://blog.lindexi.com/post/VisualStudio-2019-%E6%96%B0%E7%89%B9%E6%80%A7.html">VisualStudio 2019 新特性</a></p>

:ET