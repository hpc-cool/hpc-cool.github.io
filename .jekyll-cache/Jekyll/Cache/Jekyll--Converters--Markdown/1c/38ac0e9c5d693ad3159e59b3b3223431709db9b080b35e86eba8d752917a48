I"b<p>UWP 对 读写 XML做了一些修改，但和之前 WPF 的方法没有大的区别。
我们先来说下什么是 XML ，
XML 其实是 树结构，可以表达复杂的结构，所以在定制要求高的、或其他方面如json 做不到的结构，那么一般就使用XML，如果XML的数据结构都做不到，那么基本上也难找到其他的结构。
XML 的优点是读写很简单，也支持定制。缺点是复杂，当然这也是他的优点。在网络传输数据，如果使用XML，相对的传输大小会比 Json 多两倍。所以是不是要用到这么高级的结构，还是看需要。
wr 很喜欢用 XML，可以看到我们的项目，<code class="language-plaintext highlighter-rouge">*.csproj</code> 和页面 xaml 都是XML，当然Html也是，Xml 其实还可以用作本地数据库，所以 XML 还是很重要。
本文就提供简单的方法来读写 XML 。提供方法有两个，放在前面的方法是比较垃圾的方法，放在后面的才是我希望大家使用的。
如果遇到了 C# 或 UWP 读取 xml 返回的 Node 是空，那么请检查命名空间，关于命名空间内容，请继续看博客。</p>

<!--more-->

<!-- CreateTime:2018/8/10 19:16:51 -->

<div id="toc"></div>

<h2 id="xml-语法">xml 语法</h2>

<p>xml 一开始一般就是 文档声明</p>

<p>文档声明就是</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;?</span><span class="n">xml</span> <span class="n">version</span><span class="p">=</span><span class="s">"1.0"</span> <span class="n">encoding</span><span class="p">=</span><span class="s">"编码方式"</span> <span class="n">standalone</span><span class="p">=</span><span class="s">"yes|no"</span><span class="p">?&gt;</span>

</code></pre></div></div>

<p>XML声明放在XML文档的第一行</p>

<p>XML声明由以下几个部分组成：</p>

<ul>
  <li>
    <p>version 文档符合XML1.0规范</p>
  </li>
  <li>
    <p>encoding 文档字符编码，比如”gb2312”</p>
  </li>
  <li>
    <p>standalone 文档定义是否独立使用</p>
  </li>
  <li>
    <p>standalone=”yes” 可选</p>
  </li>
  <li>
    <p>standalone=”no”   默认</p>
  </li>
</ul>

<p>对于XML标签中出现的所有空格和换行，XML解析程序都会当作标签内容进行处理。</p>

<p>属性值用双引号（”）或单引号（’）分隔</p>

<p>如果希望知道更多，请看：<a href="http://www.cnblogs.com/yaoyinglong/p/xml.html">http://www.cnblogs.com/yaoyinglong/p/xml.html</a></p>

<p>下面就是一个 xml 的读写方法。</p>

<h2 id="xmldocument">XmlDocument</h2>

<p>在 UWP 如果需要 读取解析xml 我们可以使用 XmlDocument 。</p>

<p>一开始需要创建 XmlDocument ，创建 XmlDocument 有三个方法，首先是从 StorageFile 创建。本文下面的 file 就是一个 StorageFile ，获得 StorageFile 的方法参见<a href="https://blog.csdn.net/lindexi_gd/article/details/49007841">win10 UWP读写文件 - CSDN博客</a></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">XmlDocument</span><span class="p">.</span><span class="nf">LoadFromFileAsync</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>   <span class="err">读取</span><span class="n">xml</span>


</code></pre></div></div>

<p>注意要等待，而不是直接使用这句话，等待的方法是添加 <code class="language-plaintext highlighter-rouge">await</code> 。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="kt">var</span> <span class="n">file</span> <span class="p">=</span> <span class="nf">GetStorageFile</span><span class="p">();</span> <span class="c1">// 获得文件的方法有很多，请使用一个方法获得需要读取的文件，如 FileOpenPicker 或访问应用文件</span>
 <span class="k">await</span> <span class="n">XmlDocument</span><span class="p">.</span><span class="nf">LoadFromFileAsync</span><span class="p">(</span><span class="n">file</span><span class="p">);</span>  <span class="c1">// 读取xml</span>
</code></pre></div></div>

<p>通过这个方法就可以拿到加载的文件内容转换的 xml 。</p>

<p>第二方法：从Uri创建，<code class="language-plaintext highlighter-rouge">XmlDocument.LoadFromUriAsync(uri);   </code>，和上面的方法一样，需要等待。</p>

<p>第三方法：先创建一个 XmlDocument 然后使用 Load 函数加载。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            
            <span class="n">XmlDocument</span> <span class="n">doc</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XmlDocument</span><span class="p">();</span>
              
            <span class="n">doc</span><span class="p">.</span><span class="nf">LoadXml</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

</code></pre></div></div>

<p>注意str是字符串，也就是从文件或其他地方拿到的一个字符串。如果字符串的 xml 格式错误会出现异常。</p>

<p>读取xml之后需要解析。</p>

<p>如果想在 xml 中获取某个标签，假如我们获取的是 Page.xaml 的 TextBlock ，那么我们可以遍历一次 doc.FirstChild 拿到。这里的 doc 就是从刚才读取的时候拿到的。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">grid</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">FirstChild</span><span class="p">.</span><span class="n">ChildNodes</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">grid</span><span class="p">.</span><span class="n">Count</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="n">grid</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">temp</span><span class="p">.</span><span class="n">NodeName</span> <span class="p">==</span> <span class="s">"TextBlock"</span><span class="p">)</span>
                <span class="p">{</span>

                <span class="p">}</span>
            <span class="p">}</span>

</code></pre></div></div>

<p>大概是一个垃圾办法，我在下面写一个简单的方法，一般放在最前写的就是最垃圾的方法。</p>

<p>获取了标签，我们还想获取属性，我们可以使用 IXmlNode 的 Attributes 。Attributes 就是所有的属性，假如我们想得到 TextBlock 的 Name ，那么可以使用<code class="language-plaintext highlighter-rouge">attribute.NodeName</code>判断当前的值是不是需要</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                    <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">attribute</span> <span class="k">in</span> <span class="n">temp</span><span class="p">.</span><span class="n">Attributes</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">if</span> <span class="p">(</span><span class="n">attribute</span><span class="p">.</span><span class="n">NodeName</span> <span class="p">==</span> <span class="s">"Name"</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="n">name</span> <span class="p">=</span> <span class="s">"TextBlock"</span> <span class="p">+</span> <span class="n">attribute</span><span class="p">.</span><span class="n">InnerText</span><span class="p">;</span>
                        <span class="p">}</span>
                    <span class="p">}</span>

</code></pre></div></div>

<p>如果你想用 Linq 去查而不使用循环，那么我希望你看到下面的 <a href="# Linq 读写 XML">Linq读写 XML</a>再写代码，我下面有一个简单的方法。</p>

<p>如何去写入或创建节点，请看：http://www.cnblogs.com/zery/p/3362480.html</p>

<p>需要注意的是，如果属性有命名空间，那么刚才的方法是比较难用的。</p>

<h2 id="linq-读写-xml">Linq 读写 XML</h2>

<p>这个是我推荐的方法。</p>

<p>首先来说下如何从文件创建 xml ，我们需要使用 <code class="language-plaintext highlighter-rouge">XDocument</code> ，这里的 file 同样是 StorageFile ，感谢<a href="https://my.csdn.net/yueguogaoshan">yueguogaoshan</a> 提出了我这里没有告诉大家 file 是从哪里获得。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">XDocument</span> <span class="n">doc</span> <span class="p">=</span> <span class="n">XDocument</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="k">new</span> <span class="nf">StreamReader</span><span class="p">(</span>
                <span class="k">await</span> <span class="n">file</span><span class="p">.</span><span class="nf">OpenStreamForReadAsync</span><span class="p">()));</span>

</code></pre></div></div>

<p>如果需要从字符串创建，那么使用 StringReader 传入字符串。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">XDocument</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="k">new</span> <span class="nf">StringReader</span><span class="p">(</span><span class="n">str</span><span class="p">));</span>

</code></pre></div></div>

<p>使用的时候，需要<code class="language-plaintext highlighter-rouge">using System.Xml.Linq;</code></p>

<p>我们还是来读一个 xaml ，假如我们想拿出所有的 TextBlock ，那么我们有简单的方法。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">page</span> <span class="p">=</span> <span class="n">doc</span><span class="p">.</span><span class="n">Root</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">name</span> <span class="p">=</span> <span class="n">page</span><span class="p">.</span><span class="n">Name</span><span class="p">.</span><span class="n">NamespaceName</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">textBlockList</span> <span class="p">=</span> <span class="n">page</span><span class="p">.</span><span class="nf">Descendants</span><span class="p">(</span><span class="n">XName</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"TextBlock"</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>

</code></pre></div></div>

<p>注意，我们的 Descendants 参数是 XName，需要使用命名空间，一开始我就不知道需要命名空间，总是没找到 TextBlock 。希望大家在网上看到的博客写的是 string 字符串，需要记住我们的 Descendants 参数是 XName ，因为两个类型支持隐式转换，所以开始不知道可以传入。</p>

<p>因为我们 xaml 的 TextBlock 是使用命名空间，和简单的 xml 不同，当然，xml 也是可以使用命名空间。其实不可以去责怪大神们没有写 Descendants 的参数是 XName ，因为我们基本遇到的 XML 都不会用到 命名空间。</p>

<p>那么我们就可以简单从 xaml 拿出所有的 TextBlock ，不管他放在多少个 Grid 里。</p>

<p><img src="http://image.acmx.xyz/e53972be-081c-4087-9ea1-bff50ae213b8201714201632.jpg" alt="" /></p>

<p>看到上面的图片，放了5层的 TextBlock 也可以拿到。</p>

<p>然后我们如何拿到属性，在知道属性的名称情况，可以使用<code class="language-plaintext highlighter-rouge">temp.Attribute("属性名")?.Value</code>来获得，Attribute 的参数是 XName，那么 为何我们还直接用 string，原因是除了开始用冒号分开的属性，如<code class="language-plaintext highlighter-rouge">x:Name</code>，其他的都可以直接使用 string。</p>

<p>那么如果是<code class="language-plaintext highlighter-rouge">x:Name</code>的属性，我们需要使用 x 的命名空间 <code class="language-plaintext highlighter-rouge">http://schemas.microsoft.com/winfx/2006/xaml</code></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="kt">string</span> <span class="n">textname</span> <span class="p">=</span> <span class="n">textBlock</span><span class="p">.</span><span class="nf">Attribute</span><span class="p">(</span><span class="n">XName</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"Name"</span><span class="p">,</span> <span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span><span class="p">))?.</span><span class="n">Value</span><span class="p">;</span>


</code></pre></div></div>

<p>获取完属性，我们需要知道如何添加属性。</p>

<p>我们可以使用 SetAttributeValue 来添加删除属性。</p>

<p>假如我们添加 <code class="language-plaintext highlighter-rouge">x:Uid</code> ，value 是 name</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                <span class="n">textBlock</span><span class="p">.</span><span class="nf">SetAttributeValue</span><span class="p">(</span><span class="n">XName</span><span class="p">.</span><span class="nf">Get</span><span class="p">(</span><span class="s">"Uid"</span><span class="p">,</span> <span class="s">"http://schemas.microsoft.com/winfx/2006/xaml"</span><span class="p">),</span> <span class="n">name</span><span class="p">);</span>


</code></pre></div></div>

<p>如果我们要删除 Text ，那么使用 <code class="language-plaintext highlighter-rouge">textBlock.SetAttributeValue("Text",null);</code></p>

<p>value 是 null，就删除属性。</p>

<p>说完如何添加属性，那么如何添加 node</p>

<p>我们需要用到 XElement</p>

<p>假如我们要添加一个</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nt">&lt;node</span> <span class="na">name=</span><span class="s">"lindexi"</span><span class="nt">/&gt;</span>

</code></pre></div></div>

<p>那么我们可以使用</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>                            <span class="kt">var</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XElement</span><span class="p">(</span><span class="s">"node"</span><span class="p">);</span>
                            <span class="n">node</span><span class="p">.</span><span class="nf">SetAttributeValue</span><span class="p">(</span><span class="s">"name"</span><span class="p">,</span><span class="s">"lindexi"</span><span class="p">);</span>
                            <span class="n">doc</span><span class="p">.</span><span class="n">Root</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

</code></pre></div></div>

<p>写完保存<code class="language-plaintext highlighter-rouge">doc.Save(await file.OpenStreamForWriteAsync());</code></p>

<p>XDocument 和 WPF 的CUID都一样，如果需要删除或其他的方法，请去找WPF的方法。</p>

<p>我使用 XDocument 把 <code class="language-plaintext highlighter-rouge">*.csproj </code> 的所有文件拿出来，代码：<a href="https://gist.github.com/lindexi/813e4b7111c16ac7b8a5149f44226e30">https://gist.github.com/lindexi/813e4b7111c16ac7b8a5149f44226e30</a></p>

<script src="https://gist.github.com/lindexi/813e4b7111c16ac7b8a5149f44226e30.js"></script>

<p>最近看 xml 是因为我在写一个多语言自动拿出来的工具。名字还没想好，功能大概是我们在写一个Xaml ，因为之前没有想做多语言，于是我们把所有的 TextBlock 都写了 Text ，没有写 Uid，在想做多语言时，我们需要拿出所有的 Text 的文字，给每个 TextBlock 一个 Uid，写在 resw 。如果我有 100000 个 TextBlock ，那么对每个 TextBlock 的操作是拿出 Text，在资源写上 uid 和粘贴 Text，返回 TextBlock 写 Uid，大概5个操作。那么我们就需要做 500000 次。</p>

<p>我这个软件可以帮助大家，自动拿出 TextBlock 的Text 放在资源文件。</p>

<p>还没做出来，所以就不说啦。</p>

<p>下面是我看到的xml相关博客：</p>

<!-- 可以看到，我们使用 StreamReader ，于是我们在里面使用  -->

<p>http://www.cnblogs.com/portalsky/archive/2008/09/11/1289461.html</p>

<p>http://blog.csdn.net/cdjcong/article/details/8473539</p>

<p>http://blog.csdn.net/ht_zhaoliubin/article/details/38900275</p>

<p>http://www.cnblogs.com/zery/p/3362480.html</p>

<p>关于命名空间：https://msdn.microsoft.com/en-us/library/aa468565.aspx?f=255&amp;MSPPError=-2147217396</p>

<h2 id="wpf-读xml">WPF 读XML</h2>

<p>可以使用 XmlDocument 读 xml ，如果遇到命名空间问题就建议使用 XmlNamespaceManager ，在 WPF 的读写有一些不同。</p>

<p>假设一个属性存在命名空间，必须使用 XmlNamespaceManager 。如果没有使用，SelectSingleNode 函数返回空。</p>

<p>在拿到 XmlNamespaceManager 之前需要知道 xml 的内容，通过读取 xml 内容可以知道元素的 XmlNamespaceManager ，使用 <code class="language-plaintext highlighter-rouge">document.NameTable</code> 可以拿到命名空间。</p>

<p>新建一个 XmlNamespaceManager 的方法是拿到 document.NameTable ，这里的 document 就是 XmlDocument ，获得 XmlDocument 的方法和 UWP 差不多，大家可以看本文最后的例子。</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">new</span> <span class="nf">XmlNamespaceManager</span><span class="p">(</span><span class="n">document</span><span class="p">.</span><span class="n">NameTable</span><span class="p">)</span>
            <span class="p">{</span>

            <span class="p">};</span>
</code></pre></div></div>

<p>如果需要设置自己的命名空间，可以使用这个<code class="language-plaintext highlighter-rouge">XmlNamespaceManager.AddNamespace("随意名称", NamespaceURI);</code></p>

<p>如果看不懂上面写的，请看例子</p>

<p>假如要读取项目xml，也就是C#项目文件</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="cp">&lt;?xml version="1.0" encoding="utf-8"?&gt;</span>
<span class="nt">&lt;Project</span> <span class="na">ToolsVersion=</span><span class="s">"12.0"</span> <span class="na">DefaultTargets=</span><span class="s">"Build"</span> <span class="na">xmlns=</span><span class="s">"http://schemas.microsoft.com/developer/msbuild/2003"</span><span class="nt">&gt;</span>
  <span class="nt">&lt;Import</span> <span class="na">Project=</span><span class="s">"$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props"</span> <span class="na">Condition=</span><span class="s">"Exists('$(MSBuildExtensionsPath)\$(MSBuildToolsVersion)\Microsoft.Common.props')"</span> <span class="nt">/&gt;</span>
<span class="nt">&lt;/Project&gt;</span>
</code></pre></div></div>

<p>可以使用下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">XmlDocument</span> <span class="n">document</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XmlDocument</span><span class="p">();</span>
            <span class="n">document</span><span class="p">.</span><span class="nf">Load</span><span class="p">(</span><span class="s">"1.xml"</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">temp</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XmlNamespaceManager</span><span class="p">(</span><span class="n">document</span><span class="p">.</span><span class="n">NameTable</span><span class="p">)</span>
            <span class="p">{</span>

            <span class="p">};</span>
            <span class="n">temp</span><span class="p">.</span><span class="nf">AddNamespace</span><span class="p">(</span><span class="s">"xm"</span><span class="p">,</span> <span class="n">document</span><span class="p">.</span><span class="n">DocumentElement</span><span class="p">.</span><span class="n">NamespaceURI</span><span class="p">);</span>
            <span class="n">XmlNode</span> <span class="n">root</span> <span class="p">=</span> <span class="n">document</span><span class="p">.</span><span class="nf">SelectSingleNode</span><span class="p">(</span><span class="s">"xm:Project"</span><span class="p">,</span><span class="n">temp</span><span class="p">);</span>
            <span class="n">XmlNode</span> <span class="n">t</span> <span class="p">=</span> <span class="n">root</span><span class="p">.</span><span class="nf">SelectSingleNode</span><span class="p">(</span><span class="s">"xm:Import"</span><span class="p">,</span><span class="n">temp</span><span class="p">);</span>
</code></pre></div></div>

<h2 id="wpf-读写-xaml">WPF 读写 xaml</h2>

<p>实际上 wpf 读写和 UWP 相同，所以就不在这里多说了。</p>

<p>那么如何写出下面的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;?</span><span class="n">xml</span> <span class="n">version</span><span class="p">=</span><span class="s">"1.0"</span> <span class="n">encoding</span><span class="p">=</span><span class="s">"utf-16"</span><span class="p">?&gt;</span>
<span class="p">&lt;</span><span class="n">_XPXML</span> <span class="n">Note</span><span class="p">=</span><span class="s">""</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="n">_InvTrans</span> <span class="n">IC</span><span class="p">=</span><span class="s">"010006"</span> <span class="p">/&gt;</span>
<span class="p">&lt;/</span><span class="n">_XPXML</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>可以使用这个方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>           <span class="n">XDocument</span> <span class="n">doc</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XDocument</span><span class="p">();</span>
            <span class="n">XElement</span> <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XElement</span><span class="p">(</span><span class="s">"_XPXML"</span><span class="p">);</span>
            <span class="n">node</span><span class="p">.</span><span class="nf">SetAttributeValue</span><span class="p">(</span><span class="s">"Note"</span><span class="p">,</span> <span class="s">""</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">invTrans</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">XElement</span><span class="p">(</span><span class="s">"_InvTrans"</span><span class="p">);</span>
            <span class="n">node</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">invTrans</span><span class="p">);</span>
            <span class="n">invTrans</span><span class="p">.</span><span class="nf">SetAttributeValue</span><span class="p">(</span><span class="s">"IC"</span><span class="p">,</span> <span class="s">"010006"</span><span class="p">);</span>

            <span class="n">doc</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

            <span class="n">StringBuilder</span> <span class="n">str</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StringBuilder</span><span class="p">();</span>
            <span class="n">TextWriter</span> <span class="n">stream</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StringWriter</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
            <span class="n">doc</span><span class="p">.</span><span class="nf">Save</span><span class="p">(</span><span class="n">stream</span><span class="p">);</span>
</code></pre></div></div>

:ET