I"3<p>本文来告诉大家在C#很少有人会发现的科技。即使是工作了好多年的老司机也不一定会知道这些科技，如果觉得我是在骗你，那么请看看本文的内容</p>

<!--more-->

<!-- CreateTime:2019/11/29 10:12:43 -->

<div id="toc"></div>

<p>原本最初 C# 的设计是简单和高效开发的，在经过了这么多年众多公司和开发者的努力下，整个 C# 里面包含了大量有趣的功能。其中一部分功能是针对于某些特殊需求设计的，例如高性能或高并发或无内存回收等。在经过了 10 多年的迭代，很少人能完全了解整个 C# 语言和框架级做了哪些有趣的功能</p>

<p>我在网上找了很多大神的博客，然后和很多大神聊天，知道了一些科技，于是就在本文和大家分享一下。如果大家有了解本博客里面没有收藏的科技，还请告诉我</p>

<p>现在整个 C# 从编译器到运行时都是开源的，所有权在 dotnet 基金会上，全部开源的项目都基于最友好的 MIT 协议和 Apache 2 开源协议，文档协议遵循CC-BY协议。这将允许任何人任何组织和企业任意处置，包括使用，复制，修改，合并，发表，分发，再授权，或者销售。唯一的限制是，软件中必须包含上述版 权和许可提示，后者协议将会除了为用户提供版权许可之外，还有专利许可，并且授权是免费，无排他性的(任何个人和企业都能获得授权)并且永久不可撤销，用户使用.NET 和 C# 完全不用担心收费问题和版权问题，以及后续无法维护问题。而 dotnet 基金会是一个开放的平台，我也是 dotnet 基金会的成员之一。微软在 2020 的时候依然是 dotnet 基金会最大的支持组织</p>

<p>现在最火的 dotnet 仓库是 <a href="https://github.com/dotnet/csharplang">dotnet csharplang</a> 仓库，当前的 C# 语言特性由整个社区决定，这是一个官方开放用来讨论 C# 语言未来的仓库，天天都有大佬们在讨论语言的特性，欢迎大家加入</p>

<p>接下来让我告诉大家一些很少有人会发现的科技</p>

<h2 id="无限级判断空">无限级判断空</h2>

<p>在 C# 6.0 可以使用<code class="language-plaintext highlighter-rouge">??</code>判断空，那么就可以使用下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">v1</span> <span class="p">=</span> <span class="s">"123"</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">v2</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">v3</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">v</span> <span class="p">=</span> <span class="n">v1</span> <span class="p">??</span> <span class="n">v2</span> <span class="p">??</span> <span class="n">v3</span><span class="p">;</span>
</code></pre></div></div>

<p>实际上可以无限的使用<code class="language-plaintext highlighter-rouge">??</code>判断前面一个函数为空，那么问题来了，下面的代码输出的是多少？</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="m">2</span> <span class="p">+</span> <span class="n">foo</span><span class="p">?.</span><span class="n">N</span> <span class="p">??</span> <span class="m">1</span><span class="p">;</span>
</code></pre></div></div>

<p>上面代码的 foo 就是空的，那么 n 是多少？是 1 还是 2 还是 3 还是空？</p>

<p>想要了解这道题的推导过程请看<a href="https://blog.lindexi.com/post/C-%E9%AB%98%E7%BA%A7%E9%9D%A2%E8%AF%95%E9%A2%98.html">C# 高级面试题</a> 里面写了很多老司机都不一定能解出</p>

<h2 id="使用-using-关键词省略长的定义">使用 using 关键词省略长的定义</h2>

<p>例如有下面这个代码，在这个代码里面使用了很多的 List 嵌套，如下面代码所示里面有很多定义的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">.</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">.</span><span class="n">List</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">.</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;,</span> <span class="kt">string</span><span class="p">&gt;();</span>
</code></pre></div></div>

<p>可以看到上面代码中，有大量的代码都是用来作为类型的定义，假设这个值作为某个方法的参数，那才是可怕</p>

<p>一个简单的方法是使用 using 关键词，如在文件的开头添加如下代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">HvcnrclHnlfk</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">.</span><span class="n">Dictionary</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">.</span><span class="n">List</span><span class="p">&lt;</span><span class="n">System</span><span class="p">.</span><span class="n">Collections</span><span class="p">.</span><span class="n">Generic</span><span class="p">.</span><span class="n">List</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">&gt;&gt;,</span><span class="kt">string</span><span class="p">&gt;;</span>
</code></pre></div></div>

<p>在添加了上面代码之后，在这个文件里的所有用到如上面很长的定义的代码都可以使用 <code class="language-plaintext highlighter-rouge">using</code> 后面的值可以代替，如本文上面使用了 <code class="language-plaintext highlighter-rouge">HvcnrclHnlfk</code> 这个词，来看看替换之后的代码长度</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">HvcnrclHnlfk</span><span class="p">();</span>
</code></pre></div></div>

<h2 id="辣么大">辣么大</h2>

<p>实际上写到这里我有些不好意思，好像刚刚说的都是大家都知道的，那么我就要开始写大家很少知道的科技</p>

<p>等等，什么是 <code class="language-plaintext highlighter-rouge">辣么大</code> 大哇？其实这是 lambda 表达式的翻译</p>

<p>请看看下面这段有趣的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">Func</span><span class="p">&lt;</span><span class="kt">string</span><span class="p">,</span><span class="kt">string</span><span class="p">,</span> <span class="n">EventHandler</span><span class="p">&gt;</span> <span class="n">foo</span> <span class="p">=</span> <span class="p">(</span><span class="n">x</span><span class="p">,</span> <span class="n">y</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="p">(</span><span class="n">s</span><span class="p">,</span> <span class="n">e</span><span class="p">)</span> <span class="p">=&gt;</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">button</span> <span class="p">=</span> <span class="p">(</span><span class="n">Button</span><span class="p">)</span> <span class="n">s</span><span class="p">;</span>
                <span class="n">button</span><span class="p">.</span><span class="n">Left</span> <span class="p">=</span> <span class="n">x</span><span class="p">;</span>
                <span class="n">button</span><span class="p">.</span><span class="n">Top</span> <span class="p">=</span> <span class="n">y</span><span class="p">;</span>
            <span class="p">};</span>

            <span class="n">Button1</span><span class="p">.</span><span class="n">Click</span> <span class="p">+=</span> <span class="nf">foo</span><span class="p">(</span><span class="m">0</span><span class="p">,</span> <span class="p">-</span><span class="m">1</span><span class="p">);</span>
</code></pre></div></div>

<p>上面的代码通过一个 lambda 表达式返回一个另一个 lambda 表达式，或者说用一个委托返回另一个委托。这是一个特别有趣的写法，通过函数返回函数的思想可以用来写出一些有趣的逻辑，特别是在多层嵌套的时候</p>

<p>当然使用委托可是会出现另一个问题的，请问下面的代码实际调用的是哪个委托，下面代码的 a 和 b 和 c 都是 <code class="language-plaintext highlighter-rouge">Action</code> 委托，同时都不是空的</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">((</span><span class="n">a</span> <span class="p">+</span> <span class="n">b</span> <span class="p">+</span> <span class="n">c</span><span class="p">)</span> <span class="p">-</span> <span class="p">(</span><span class="n">a</span> <span class="p">+</span> <span class="n">c</span><span class="p">))();</span>
</code></pre></div></div>

<p>在数学上，其实函数也可以视为变量，很有科技范的 C# 当然也支持如此的功能，将函数包装为委托的时候，可以让委托本身支持加减法哦，只是这个加减法的规则有些诡异。不信，请猜猜上面代码执行了什么函数</p>

<h2 id="冲突的类型">冲突的类型</h2>

<p>在遇到某些类型，特别是放在 NuGet 上的多个不同的库里面的类型，这些类型有相同的类名，如 Data 或 Control 等很通用的命名的时候，在代码中如果需要同时使用这两个类，就需要补全整个命名空间，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">var</span> <span class="n">webControl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Web</span><span class="p">.</span><span class="n">UI</span><span class="p">.</span><span class="n">WebControls</span><span class="p">.</span><span class="nf">Control</span><span class="p">();</span>
<span class="kt">var</span> <span class="n">formControl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Forms</span><span class="p">.</span><span class="nf">Control</span><span class="p">();</span>
</code></pre></div></div>

<p>如果经常使用这两个控件，那么就需要写很多补全命名空间的代码，代码很多。好在微软的大佬们给出了一个坑方法，使用这个方法可以不写命名空间，或者说只需要在文件开始 using 一次，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">using</span> <span class="nn">web</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Web</span><span class="p">.</span><span class="n">UI</span><span class="p">.</span><span class="n">WebControls</span><span class="p">;</span>
<span class="k">using</span> <span class="nn">win</span> <span class="p">=</span> <span class="n">System</span><span class="p">.</span><span class="n">Windows</span><span class="p">.</span><span class="n">Forms</span><span class="p">;</span>

<span class="n">web</span><span class="p">::</span><span class="n">Control</span> <span class="n">webControl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">web</span><span class="p">::</span><span class="nf">Control</span><span class="p">();</span>
<span class="n">win</span><span class="p">::</span><span class="n">Control</span> <span class="n">formControl</span> <span class="p">=</span> <span class="k">new</span> <span class="n">win</span><span class="p">::</span><span class="nf">Control</span><span class="p">();</span>
</code></pre></div></div>

<p>参见：<a href="https://stackoverflow.com/a/9099/6116637">https://stackoverflow.com/a/9099/6116637</a></p>

<h2 id="extern-alias">extern alias</h2>

<p>如果使用了两个不同的程序集放在两个不同的 dll 文件里面，这两个程序集都有相同命名空间和类型，那么如何使用指定的库</p>

<p>如下面代码所示，在两个 dll 里面都定义了 <code class="language-plaintext highlighter-rouge">F.Foo</code> 类型</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//a.dll</span>

<span class="k">namespace</span> <span class="nn">F</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">class</span> <span class="nc">Foo</span>
	<span class="p">{</span>

	<span class="p">}</span>
<span class="p">}</span>

<span class="c1">//b.dll</span>

<span class="k">namespace</span> <span class="nn">F</span>
<span class="p">{</span>
	<span class="k">public</span> <span class="k">class</span> <span class="nc">Foo</span>
	<span class="p">{</span>
		
	<span class="p">}</span>
<span class="p">}</span>

</code></pre></div></div>

<p>这时就可以使用 extern alias 关键词</p>

<p>参见：<a href="http://www.cnblogs.com/fresky/archive/2012/12/24/2831697.html">C#用extern alias解决两个assembly中相同的类型全名 - fresky - 博客园</a></p>

<h2 id="字符串">字符串</h2>

<p>大家看到了 C# 6.0 的<code class="language-plaintext highlighter-rouge">$</code>，是不是可以和<code class="language-plaintext highlighter-rouge">@</code>一起？</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">str</span> <span class="p">=</span> <span class="s">"kktpqfThiq"</span><span class="p">;</span>
            <span class="kt">string</span> <span class="n">foo</span> <span class="p">=</span> <span class="s">$@"换行</span><span class="err">
</span><span class="p">{</span><span class="n">str</span><span class="p">}</span><span class="s">"</span><span class="p">;</span>
</code></pre></div></div>

<p><del>注意两个的顺序，反过来直接告诉你代码不能这样写</del></p>

<p>此知识点不再适用，因为在 C# 8.0 的时候，可以按照任意的顺序使用 <code class="language-plaintext highlighter-rouge">$</code> 和 <code class="language-plaintext highlighter-rouge">@</code> 标记。详细请看 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/language-reference/tokens/interpolated">$ - 字符串内插 - C# 参考</a> 特别感谢 592844340 群内热心人员勘误</p>

<h2 id="特殊关键字">特殊关键字</h2>

<p>实际上有下面几个关键字是没有详细的文档，可能只有微软的编译器才知道</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">__makeref</span>

<span class="n">__reftype</span>

<span class="n">__refvalue</span>

<span class="n">__arglist</span>
</code></pre></div></div>

<p>不过在 C# 7.2 可以使用其他的关键字做到一些功能，详细请看我的 C# 7.0 博客</p>

<h2 id="使用-unions-c-一样的">使用 Unions （C++ 一样的）</h2>

<p>如果看到 C++ 可以使用内联，不要说 C# 没有这个功能，实际上也可以使用 FieldOffset 特性实现和 C++ 一样的内联的功能 ，请看下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">[</span><span class="nf">StructLayout</span><span class="p">(</span><span class="n">LayoutKind</span><span class="p">.</span><span class="n">Explicit</span><span class="p">)]</span>
<span class="k">public</span> <span class="k">class</span> <span class="nc">A</span>
<span class="p">{</span>
    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">0</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">byte</span> <span class="n">One</span><span class="p">;</span>

    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">1</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Two</span><span class="p">;</span>

    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">2</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Three</span><span class="p">;</span>

    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">3</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">byte</span> <span class="n">Four</span><span class="p">;</span>

    <span class="p">[</span><span class="nf">FieldOffset</span><span class="p">(</span><span class="m">0</span><span class="p">)]</span>
    <span class="k">public</span> <span class="kt">int</span> <span class="n">Int32</span><span class="p">;</span>
<span class="p">}</span>
</code></pre></div></div>

<p>如下面代码就定义了<code class="language-plaintext highlighter-rouge">int</code>变量，修改这个变量就是修改其他的三个变量</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
    <span class="p">{</span>
        <span class="n">A</span> <span class="n">a</span> <span class="p">=</span> <span class="k">new</span> <span class="n">A</span> <span class="p">{</span> <span class="n">Int32</span> <span class="p">=</span> <span class="kt">int</span><span class="p">.</span><span class="n">MaxValue</span> <span class="p">};</span>

        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Int32</span><span class="p">);</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"{0:X} {1:X} {2:X} {3:X}"</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">One</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Two</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Three</span><span class="p">,</span> <span class="n">a</span><span class="p">.</span><span class="n">Four</span><span class="p">);</span>

        <span class="n">a</span><span class="p">.</span><span class="n">Four</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="n">a</span><span class="p">.</span><span class="n">Three</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">a</span><span class="p">.</span><span class="n">Int32</span><span class="p">);</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>运行代码可以看到输出如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="m">2147483647</span>
<span class="n">FF</span> <span class="n">FF</span> <span class="n">FF</span> <span class="m">7F</span>
<span class="m">65535</span>
</code></pre></div></div>

<p>可以看到修改其中某个值都会相互影响，这几个值共用了相同的一个内存空间</p>

<h2 id="接口默认方法">接口默认方法</h2>

<p>实际上可以给接口使用默认方法，使用的方式如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">public</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">(</span><span class="k">this</span> <span class="n">IF1</span> <span class="n">foo</span><span class="p">)</span>
<span class="p">{</span>
     <span class="c1">//实际上大家也看到是如何定义</span>
<span class="p">}</span>
</code></pre></div></div>

<p>当然了，在 C# 8.0 还有更直接的方法，详细请看 <a href="https://docs.microsoft.com/zh-cn/dotnet/csharp/tutorials/default-interface-methods-versions?WT.mc_id=WD-MVP-5003260">在 C# 中使用默认接口方法安全地更新接口</a></p>

<h2 id="stackalloc">stackalloc</h2>

<p>很多人都不知道这个科技，这是不安全代码，从栈申请空间</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">int</span><span class="p">*</span> <span class="n">block</span> <span class="p">=</span> <span class="k">stackalloc</span> <span class="kt">int</span><span class="p">[</span><span class="m">100</span><span class="p">];</span> 
</code></pre></div></div>

<p>使用的时候需要小心你的栈也许会炸掉</p>

<p>参见：<a href="https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/keywords/stackalloc">stackalloc</a></p>

<h2 id="指定编译">指定编译</h2>

<p>这个是一个有趣的特性实现的功能，是一个编译器技术，写给编译器看的特性。使用 Conditional 特性可以让代码在指定条件不使用，如下面的代码，规定了只有在 DEBUG 宏定义的时候才让 F2 方法生效。因此在 Release 下就不会使用 F2 方法了</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">sealed</span> <span class="n">clas</span> <span class="n">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="n">Foo</span> <span class="nf">F1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"进入F1"</span><span class="p">);</span>
            <span class="k">return</span> <span class="k">this</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="p">[</span><span class="nf">Conditional</span><span class="p">(</span><span class="s">"DEBUG"</span><span class="p">)]</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">F2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"F2"</span><span class="p">);</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>简单让代码跑一下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Foo</span><span class="p">();</span>
            <span class="n">foo</span><span class="p">.</span><span class="nf">F1</span><span class="p">();</span>
            <span class="n">foo</span><span class="p">.</span><span class="nf">F2</span><span class="p">();</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>结果是什么，大家也知道，在 Debug 和 Release 输出是不相同。但是这么简单的怎么会在这里说呢，请大家看看这个代码输出什么</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
     <span class="p">{</span>
         <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Foo</span><span class="p">();</span>
         <span class="n">foo</span><span class="p">.</span><span class="nf">F1</span><span class="p">().</span><span class="nf">F2</span><span class="p">();</span>
     <span class="p">}</span>
</code></pre></div></div>

<p>实际上在 Release 下什么都不会输出，此时的 F1 不会被执行</p>

<h2 id="true-判断">true 判断</h2>

<p>下面写个见鬼的代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Foo</span><span class="p">(</span><span class="m">10</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">foo</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"我的类没有继承 bool ，居然可以这样写"</span><span class="p">);</span>
            <span class="p">}</span>
</code></pre></div></div>

<p>没错 Foo 没有继承 bool 居然可以这样写</p>

<p>实际上就是重写 true 方法，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">Foo</span><span class="p">(</span><span class="kt">int</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_count</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_count</span><span class="p">;</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="k">true</span><span class="p">(</span><span class="n">Foo</span> <span class="n">mt</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">mt</span><span class="p">.</span><span class="n">_count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">bool</span> <span class="k">operator</span> <span class="k">false</span><span class="p">(</span><span class="n">Foo</span> <span class="n">mt</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">mt</span><span class="p">.</span><span class="n">_count</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

</code></pre></div></div>

<p>是不是觉得很多有人这样写，下面让大家看一个很少人会知道的科技，感谢<a href="https://walterlv.github.io/">walterlv</a> 提供</p>

<h2 id="重写运算返回">重写运算返回</h2>

<p>很少人知道实际上重写 <code class="language-plaintext highlighter-rouge">==</code> 可以返回任意的类型，而不是只有 bool 类型，请看下面代码</p>

<p><img src="http://image.acmx.xyz/lindexi%2F2018422105951305.jpg" alt="" /></p>

<p>是可以编译通过的，因为我重写运算</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>   <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
     
        <span class="k">public</span> <span class="k">static</span> <span class="kt">string</span> <span class="k">operator</span> <span class="p">==(</span><span class="n">Foo</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Foo</span> <span class="n">f2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">f1</span><span class="p">?.</span><span class="n">Count</span> <span class="p">==</span> <span class="n">f2</span><span class="p">?.</span><span class="n">Count</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="s">"lindexi"</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="kt">string</span> <span class="k">operator</span> <span class="p">!=(</span><span class="n">Foo</span> <span class="n">f1</span><span class="p">,</span> <span class="n">Foo</span> <span class="n">f2</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="s">""</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>可以重写的运算很多，返回值可以自己随意定义</p>

<h2 id="await-任何类型">await 任何类型</h2>

<p>等待任意的类型，包括已定义的基础类型，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="s">"林德熙逗比"</span><span class="p">;</span>

<span class="k">await</span> <span class="s">"不告诉你"</span><span class="p">;</span>
</code></pre></div></div>

<p>这个代码是可以编译通过的，但是只有在我的设备。在看了这个<a href="https://lindexi.gitee.io/post/C-await-%E9%AB%98%E7%BA%A7%E7%94%A8%E6%B3%95.html">博客</a>之后，可能你也可以在你的设备编译</p>

<p>其实 await 是可以写很多次的，如下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="k">await</span> <span class="s">"林德熙逗比"</span><span class="p">;</span>
</code></pre></div></div>

<h2 id="变量名使用中文">变量名使用中文</h2>

<p>实际上在C#支持所有 Unicode 字符，这是编译器支持的，所以变量名使用中文也是可以的，而且可以使用特殊的字符</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="kt">string</span> <span class="n">H</span><span class="err">\</span><span class="n">u00e5rf</span><span class="err">ø</span><span class="nf">ner</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="s">"可以编译"</span><span class="p">;</span>
        <span class="p">}</span>
</code></pre></div></div>

<p><img src="http://image.acmx.xyz/65fb6078-c169-4ce3-cdd9-e35752d07be0%2F2018316102739.jpg" alt="" /></p>

<p><img src="http://image.acmx.xyz/65fb6078-c169-4ce3-cdd9-e35752d07be0%2F2018316102848.jpg" alt="" /></p>

<h2 id="if-this--null">if this == null</h2>

<p>一般看到下面的代码都觉得是不可能进入输出的</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"this is null"</span><span class="p">);</span>
</code></pre></div></div>

<p>如果在 if 里面都能使用 this == null 成立，那么一定是vs炸了。实际上这个代码还是可以运行的</p>

<p>在一般的函数，如下面的 Foo 函数，在调用就需要使用<code class="language-plaintext highlighter-rouge">f.Foo()</code>的方法，方法里 this 就是 f 这个对象，如果 <code class="language-plaintext highlighter-rouge">f == null</code> 那么在调用方法就直接不让运行，如何到方法里的判断</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">f</span><span class="p">.</span><span class="nf">Foo</span><span class="p">();</span> <span class="c1">//如果 f 为空，那么这里就不执行</span>

<span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
<span class="p">{</span>
   <span class="c1">// 如果 this 为空，怎么可以调用这个方法</span>
   <span class="k">if</span> <span class="p">(</span><span class="k">this</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">"this is null"</span><span class="p">);</span>
<span class="p">}</span>
</code></pre></div></div>

<p>实际上是可以做的，请看<a href="https://walterlv.github.io/post/this-could-be-null.html">（C#）if (this == null)？你在逗我，this 怎么可能为 null！用 IL 编译和反编译看穿一切 - walterlv</a> 这篇博客</p>

<p>如上面博客，关键在修改 <code class="language-plaintext highlighter-rouge">callvirt</code> 为 <code class="language-plaintext highlighter-rouge">call</code> 调用，直接修改 IL 可以做出很多特殊的写法</p>

<p>那么这个可以用在哪里？可以用在防止大神反编译，如需要使用下面逻辑</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">//执行的代码</span>

<span class="c1">//不执行的代码</span>
</code></pre></div></div>

<p>此时简单的反编译也许会这么写</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="k">true</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">//执行的代码</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
   <span class="c1">//不执行的代码 </span>
<span class="p">}</span>
</code></pre></div></div>

<p>但是直接写 true 很容易让反编译看到不使用代码，而且在优化代码会被去掉，所以可以使用下面代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">if</span><span class="p">(</span><span class="k">this</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
<span class="p">{</span>
   <span class="c1">//执行的代码</span>
<span class="p">}</span>
<span class="k">else</span>
<span class="p">{</span>
   <span class="c1">//不执行的代码 </span>
<span class="p">}</span>
</code></pre></div></div>

<p>实际在微软代码也是这样写，点击<a href="https://referencesource.microsoft.com/#mscorlib/system/string.cs,507">string的实现源代码</a>可以看到微软代码</p>

<h2 id="重载的运算符">重载的运算符</h2>

<p>实际上我可以将 null 强转某个类，创建一个新的对象，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">Fantastic</span> <span class="n">fantastic</span> <span class="p">=</span> <span class="p">(</span><span class="n">FantasticInfo</span><span class="p">)</span> <span class="k">null</span><span class="p">;</span>
<span class="n">fantastic</span><span class="p">.</span><span class="nf">Foo</span><span class="p">();</span>
</code></pre></div></div>

<p>这里的 FantasticInfo 和 Fantastic 没有任何继承关系，而且调用 Foo 不会出现空引用，也就是 fantastic 是从一个空的对象创建出来的</p>

<p>是不是觉得上面的科技很黑，实际原理没有任何黑的科技，请看代码</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">Fantastic</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="nf">Fantastic</span><span class="p">()</span>
        <span class="p">{</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">static</span> <span class="k">implicit</span> <span class="k">operator</span> <span class="nf">Fantastic</span><span class="p">(</span><span class="n">FantasticInfo</span> <span class="k">value</span><span class="p">)</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">Fantastic</span><span class="p">();</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Foo</span><span class="p">()</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">class</span> <span class="nc">FantasticInfo</span>
    <span class="p">{</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>通过这个方式可以让开发者无法直接创建 Fantastic 类，而且在不知道 FantasticInfo 的情况无法创建 Fantastic 也就是让大家需要了解 FantasticInfo 才可以通过上面的方法创建，具体请看<a href="https://blog.walterlv.com/post/hide-your-constructor.html">只有你能 new 出来！.NET 隐藏构造函数的 n 种方法（Builder Pattern / 构造器模式） - walterlv</a></p>

<p>课件链接： <a href="https://r302.cc/J4gxOX">https://r302.cc/J4gxOX</a></p>

<p>当然还有新的 <a href="https://blog.lindexi.com/post/C-7.0.html">C# 7.0</a> 和 <a href="https://blog.lindexi.com/post/VisualStudio-2019-%E5%B0%9D%E8%AF%95%E4%BD%BF%E7%94%A8-C-8.0-%E6%96%B0%E7%9A%84%E6%96%B9%E5%BC%8F.html">C# 8.0</a> 的新的语法</p>

<p>例如下面的内部方法返回自身</p>

<h2 id="方法返回自身可以接近无限调用">方法返回自身可以接近无限调用</h2>

<p>有一天我看到了下面的代码，你猜小伙伴用什么代码定义了 Foo 这个代码？</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="nf">Foo</span><span class="p">()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()()();</span>
</code></pre></div></div>

<p>其实只需要定义一个委托，用内部方法实现委托，因为内部方法是可以返回自身，于是就可以使用5行代码写出 Foo 的定义</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">delegate</span> <span class="n">Foo</span> <span class="nf">Foo</span><span class="p">();</span> <span class="c1">// 定义委托</span>

<span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
<span class="p">{</span>
    <span class="n">Foo</span> <span class="nf">Foo</span><span class="p">()</span> <span class="c1">// 定义内部方法</span>
    <span class="p">{</span>
        <span class="k">return</span> <span class="n">Foo</span><span class="p">;</span>
    <span class="p">}</span>
<span class="p">}</span>
</code></pre></div></div>

<p>不过括号还不可以无限使用，因为编译器有一个表达式的长度限制</p>

<h2 id="无限长度的委托调用">无限长度的委托调用</h2>

<p>试试这个代码，也许你可以无限写下去，只要 Roslyn 不会炸就可以</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">delegate</span> <span class="n">Fx</span> <span class="nf">Fx</span><span class="p">(</span><span class="n">Fx</span> <span class="n">fx</span><span class="p">);</span>
 <span class="n">Fx</span> <span class="n">fx</span> <span class="p">=</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span>
                <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span> <span class="p">=&gt;</span> <span class="n">fx</span><span class="p">;</span>
</code></pre></div></div>

<p>以下部分准确来说是 .NET 提供的功能，请问 C# 和 .NET 是什么关系？其实我也无法用一两句话说清，扔掉了 .NET 依然可以用 C# 写程序，反过来扔掉 C# 也依然能用 .NET 写程序</p>

<h2 id="表达式树获取函数命名">表达式树获取函数命名</h2>

<p>定义一个类，下面通过表达式树从类获得函数命名</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">KzcSevfio</span><span class="p">()</span>
        <span class="p">{</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>       <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">GetMethodName</span><span class="p">&lt;</span><span class="n">Foo</span><span class="p">&gt;(</span><span class="n">foo</span> <span class="p">=&gt;</span> <span class="n">foo</span><span class="p">.</span><span class="nf">KzcSevfio</span><span class="p">());</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">GetMethodName</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Expression</span><span class="p">&lt;</span><span class="n">Action</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">action</span><span class="p">)</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="k">class</span>
        <span class="err">{</span>
            <span class="nc">if</span> <span class="p">(</span><span class="n">action</span><span class="p">.</span><span class="n">Body</span> <span class="k">is</span> <span class="n">MethodCallExpression</span> <span class="n">expression</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">expression</span><span class="p">.</span><span class="n">Method</span><span class="p">.</span><span class="n">Name</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>这样就可以拿到函数的命名</p>

<h2 id="debuggerdisplay">DebuggerDisplay</h2>

<p>如果想要在调试的时候，鼠标移动到变量显示他的信息，可以重写类的 ToString</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="k">override</span> <span class="kt">string</span> <span class="nf">ToString</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Count</span><span class="p">.</span><span class="nf">ToString</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p><img src="http://image.acmx.xyz/65fb6078-c169-4ce3-cdd9-e35752d07be0%2F201831693435.jpg" alt="" /></p>

<p>但是如果 ToString 被其他地方用了，如何显示？</p>

<p>微软告诉大家，使用 DebuggerDisplay 特性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="p">[</span><span class="nf">DebuggerDisplay</span><span class="p">(</span><span class="s">"{DebuggerDisplay}"</span><span class="p">)]</span>
    <span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">private</span> <span class="kt">string</span> <span class="n">DebuggerDisplay</span> <span class="p">=&gt;</span> <span class="s">$"(count </span><span class="p">{</span><span class="n">Count</span><span class="p">}</span><span class="s">)"</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>他可以使用私有的属性、字段，使用方法很简单</p>

<p>参见<a href="https://msdn.microsoft.com/en-us/library/x810d419.aspx">Using the DebuggerDisplay Attribute</a></p>

<h2 id="数字格式">数字格式</h2>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kt">string</span> <span class="n">format</span> <span class="p">=</span> <span class="s">"000;-#;(0)"</span><span class="p">;</span>

<span class="kt">string</span> <span class="n">pos</span> <span class="p">=</span> <span class="m">1.</span><span class="nf">ToString</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>     <span class="c1">// 001</span>
<span class="kt">string</span> <span class="n">neg</span> <span class="p">=</span> <span class="p">(-</span><span class="m">1</span><span class="p">).</span><span class="nf">ToString</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>  <span class="c1">// -1</span>
<span class="kt">string</span> <span class="n">zer</span> <span class="p">=</span> <span class="m">0.</span><span class="nf">ToString</span><span class="p">(</span><span class="n">format</span><span class="p">);</span>     <span class="c1">// (0)</span>
</code></pre></div></div>

<p>参见：<a href="https://docs.microsoft.com/zh-cn/dotnet/standard/base-types/custom-numeric-format-strings#SectionSeparator">自定义数字格式字符串 </a></p>

<h2 id="调用堆栈">调用堆栈</h2>

<p>如果需要获得调用方法的堆栈，可以使用<a href="https://lindexi.gitee.io/post/WPF-%E5%88%A4%E6%96%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%A0%86%E6%A0%88.html">这个文章的方法</a></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>  <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">foo</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Foo</span><span class="p">();</span>
            <span class="n">foo</span><span class="p">.</span><span class="nf">F1</span><span class="p">();</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">Foo</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">F1</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="nf">F2</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">void</span> <span class="nf">F2</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">stackTrace</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">StackTrace</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">n</span> <span class="p">=</span> <span class="n">stackTrace</span><span class="p">.</span><span class="n">FrameCount</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">n</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stackTrace</span><span class="p">.</span><span class="nf">GetFrame</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="nf">GetMethod</span><span class="p">().</span><span class="n">Name</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>输出</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">F2</span>
<span class="n">F1</span>
</code></pre></div></div>

<p>参见：<a href="https://lindexi.gitee.io/post/WPF-%E5%88%A4%E6%96%AD%E8%B0%83%E7%94%A8%E6%96%B9%E6%B3%95%E5%A0%86%E6%A0%88.html">WPF 判断调用方法堆栈</a></p>

<p>欢迎加入 dotnet 职业技术学院 <a href="https://t.me/dotnet_campus">https://t.me/dotnet_campus</a> 使用 Telegram 方法请看 <a href="https://blog.lindexi.com/post/%E5%A6%82%E4%BD%95%E4%BD%BF%E7%94%A8-Telegram.html">如何使用 Telegram</a></p>

<h2 id="特别感谢">特别感谢</h2>

<p>特别感谢 <a href="https://blog.walterlv.com/">吕毅 - walterlv</a> 提供的逗比代码</p>

<p>特别感谢队长提供的 <a href="https://www.cnblogs.com/shanyou/p/13547269.html">.NET Core也是国产化信息系统开发的重要选项 - 张善友 - 博客园</a> 博客。本文开头为了更准确的描述，于是抄了队长的博客内容</p>

:ET