I"<p>æœ¬æ–‡æ¥å‘Šè¯‰å¤§å®¶åœ¨ WPF é‡Œé¢çš„ SafeMILHandleMemoryPressure ç±»çš„ä½œç”¨ã€‚è¿™æ˜¯ä¸€ä¸ª internal ä¸å¼€æ”¾çš„ç±»ï¼Œæ˜¯åœ¨ WPF ä¸­å’Œ Dx ç­‰æ¨¡å—è°ƒç”¨ä½¿ç”¨çš„ï¼Œç”¨é€”å°±æ˜¯è¾…åŠ© GC ç»Ÿè®¡å½“å‰å†…å­˜æƒ…å†µï¼Œç”¨æ¥åœ¨å†…å­˜ä¸å¤Ÿçš„æ—¶å€™è§¦å‘å›æ”¶</p>

<!--more-->

<!-- CreateTime:2020/12/25 9:09:44 -->

<!-- å‘å¸ƒ -->

<p>è¿™ä¸ªç±»æ”¾åœ¨ <code class="language-plaintext highlighter-rouge">src\Microsoft.DotNet.Wpf\src\PresentationCore\System\Windows\Media\SafeMILHandleMemoryPressure.cs</code> æ–‡ä»¶ï¼Œæ ¸å¿ƒè°ƒç”¨æ˜¯é€šè¿‡ <a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure(Int64)</a> æ–¹æ³•å‘Šè¯‰ GC å½“å‰éæ‰˜ç®¡éƒ¨åˆ†å ç”¨äº†å¤šå°‘å†…å­˜</p>

<p>æ ¹æ® <a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure(Int64) å®˜æ–¹æ–‡æ¡£</a> çš„è¯´æ³•ï¼Œè¿™ä¸ª AddMemoryPressure éœ€è¦å’Œ RemoveMemoryPressure æˆå¯¹ä½¿ç”¨ï¼Œåœ¨ä½¿ç”¨çš„æ—¶å€™å¿…é¡»ç”±ä¸šåŠ¡æ–¹æˆå¯¹è°ƒç”¨ï¼Œå¦åˆ™å°†ä¼šå½±å“ GC çš„æ•ˆç‡</p>

<p>ä¸ºä»€ä¹ˆéœ€è¦æœ‰ <a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure</a> è¿™ä¸ªæ–¹æ³•ï¼ŸåŸå› æ˜¯å‡å®šå’±çš„æ‰€æœ‰ä»£ç éƒ½æ˜¯æ‰˜ç®¡çš„æ¸…çœŸçš„ä»£ç ï¼Œé‚£ä¹ˆ GC æ˜¯èƒ½ç»Ÿè®¡å½“å‰å ç”¨äº†å¤šå°‘çš„å†…å­˜çš„ã€‚ä½†å¦‚æœå’±è°ƒç”¨äº†ä¸€äº›éæ‰˜ç®¡éƒ¨åˆ†ï¼Œè¿™äº›æ¨¡å—ä¹Ÿç”³è¯·äº†å†…å­˜ï¼Œæ­¤æ—¶çš„ GC æ˜¯ä¸äº†è§£å½“å‰ä½¿ç”¨åˆ°å¤šå°‘å†…å­˜çš„ï¼Œå±äºè¿™ä¸ªéæ‰˜ç®¡æ¨¡å—ç”¨çš„å†…å­˜æ˜¯å¤šå°‘ã€‚é€šè¿‡ <a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure</a> è¿™ä¸ªæ–¹æ³•å¯ä»¥å‘Šè¯‰ GC å½“å‰è¿™ä¸ªéæ‰˜ç®¡æ¨¡å—ä½¿ç”¨åˆ°å¤šå°‘å†…å­˜äº†</p>

<p>è€Œ GC çš„æ¸…ç†æ˜¯éœ€è¦æ ¹æ®å½“å‰å†…å­˜å ç”¨é‡å†³å®šçš„ï¼Œå‡å®šç°åœ¨å†…å­˜å¤šçš„æ˜¯ï¼Œè€Œä¸”è¿›ç¨‹ä¹Ÿæ²¡æœ‰ç”¨å¤šå°‘å†…å­˜ï¼Œé‚£ä¹ˆ GC å°†ä¸ä¼šè¿›è¡Œå…¨æ¸…ç†ã€‚ä½†å¦‚æœå½“å‰è¿›ç¨‹ç”¨åˆ°äº†å¤§é‡çš„å†…å­˜äº†ï¼Œé‚£ä¹ˆ GC ä¹Ÿè®¸å°±éœ€è¦è€ƒè™‘æ¥ä¸€æ¬¡å®Œå…¨å†…å­˜å›æ”¶äº†ã€‚ä¸Šé¢è¯´çš„å†…å­˜å®Œå…¨å›æ”¶å¤§æ¦‚å¯ä»¥ç†è§£ä¸ºå›æ”¶åˆ°äºŒä»£åŒæ—¶å‹ç¼©å†…å­˜ï¼Œæ›´å¤šå†…å­˜ç»†èŠ‚è¯·çœ‹ä¼Ÿæ°‘å“¥ç¿»è¯‘çš„ .NETå†…å­˜ç®¡ç†å®å…¸ - æé«˜ä»£ç è´¨é‡ã€æ€§èƒ½å’Œå¯æ‰©å±•æ€§ è¿™æœ¬ä¹¦</p>

<p>é‚£å¦‚æœæˆ‘åªæ˜¯è°ƒç”¨äº† <a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure</a> ä½†æ²¡æœ‰è°ƒç”¨ RemoveMemoryPressure æ–¹æ³•ä¼šå¦‚ä½•ï¼Ÿæ­¤æ—¶çš„ GC å°†ä¼šä»¥ä¸ºå†…å­˜é‡Œé¢æœ‰è¿™äº›æ¨¡å—å ç”¨äº†å†…å­˜ï¼Œè€Œä¸”è¿™äº›æ¨¡å—ä¹Ÿæ²¡æœ‰é‡Šæ”¾</p>

<p>ä¸ºäº†èƒ½åœ¨ WPF é‡Œé¢æ›´å¥½ç®¡ç†å†…å­˜ï¼ŒåŒæ—¶æˆå¯¹è°ƒç”¨ <a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure</a> å’Œ RemoveMemoryPressure æ–¹æ³•ï¼Œè€Œä¸”æ˜¯å‡†ç¡®åœ¨éæ‰˜ç®¡é‡Šæ”¾çš„æ—¶å€™è°ƒç”¨ RemoveMemoryPressure æ–¹æ³•ï¼Œå°±å°è£…äº† SafeMILHandleMemoryPressure ç±»</p>

<p>åœ¨ SafeMILHandleMemoryPressure çš„æ„é€ å‡½æ•°é‡Œé¢ï¼Œå°†ä¼šä¼ å…¥å½“å‰éæ‰˜ç®¡æ¨¡å—ä½¿ç”¨åˆ°çš„å†…å­˜é‡</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">internal</span> <span class="nf">SafeMILHandleMemoryPressure</span><span class="p">(</span><span class="kt">long</span> <span class="n">gcPressure</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_gcPressure</span> <span class="p">=</span> <span class="n">gcPressure</span><span class="p">;</span>
            <span class="n">_refCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

            
            <span class="c1">// Removed WPF specific GC algorithm and all bitmap allocations/deallocations</span>
            <span class="c1">// are now tracked with GC.Add/RemoveMemoryPressure.</span>
            <span class="n">GC</span><span class="p">.</span><span class="nf">AddMemoryPressure</span><span class="p">(</span><span class="n">_gcPressure</span><span class="p">);</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>æ¥ç€è·Ÿéšéæ‰˜ç®¡çš„æŒ‡é’ˆå¼•ç”¨æ·»åŠ æˆ–å‡å°‘å¼•ç”¨ï¼Œç›¸å½“äºè‡ªå·±å®ç°äº†å¼•ç”¨è®¡ç®—ã€‚åœ¨å¼•ç”¨æ•°é‡ä¸º é›¶ çš„æ—¶å€™ï¼Œè°ƒç”¨ RemoveMemoryPressure æ–¹æ³•å‘Šè¯‰ GC éæ‰˜ç®¡æ²¡æœ‰å ç”¨èµ„æº</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">internal</span> <span class="k">void</span> <span class="nf">AddRef</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">_refCount</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">internal</span> <span class="k">void</span> <span class="nf">Release</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Interlocked</span><span class="p">.</span><span class="nf">Decrement</span><span class="p">(</span><span class="k">ref</span> <span class="n">_refCount</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                
                <span class="c1">// Removed WPF specific GC algorithm and all bitmap allocations/deallocations</span>
                <span class="c1">// are now tracked with GC.Add/RemoveMemoryPressure.</span>
                <span class="n">GC</span><span class="p">.</span><span class="nf">RemoveMemoryPressure</span><span class="p">(</span><span class="n">_gcPressure</span><span class="p">);</span>
                <span class="n">_gcPressure</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">// Estimated size in bytes of the unmanaged memory</span>
        <span class="k">private</span> <span class="kt">long</span> <span class="n">_gcPressure</span><span class="p">;</span>

        <span class="c1">//</span>
        <span class="c1">// SafeMILHandleMemoryPressure does its own ref counting in managed code, because the</span>
        <span class="c1">// associated memory pressure should be removed when there are no more managed</span>
        <span class="c1">// references to the unmanaged resource. There can still be references to it from</span>
        <span class="c1">// unmanaged code elsewhere, but that should not prevent the memory pressure from being</span>
        <span class="c1">// released.</span>
        <span class="c1">//</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_refCount</span><span class="p">;</span>
</code></pre></div></div>

<p>å½“å‰è¿™ä¸ªç±»åªæ˜¯åœ¨å’Œ MIL è°ƒç”¨è¿™é‡Œä½¿ç”¨ï¼Œä½†è®¾è®¡æ˜¯é€šç”¨çš„</p>

<p><a href="https://docs.microsoft.com/en-us/dotnet/api/system.gc.addmemorypressure?WT.mc_id=WD-MVP-5003260">GC.AddMemoryPressure(Int64) Method (System)</a></p>

:ET