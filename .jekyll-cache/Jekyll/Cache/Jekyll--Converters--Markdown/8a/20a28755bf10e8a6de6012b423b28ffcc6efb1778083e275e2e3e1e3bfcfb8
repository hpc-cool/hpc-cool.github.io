I" <p>本文告诉大家两个不同的方法进入全屏模式</p>

<!--more-->

<!-- CreateTime:2019/5/31 9:05:36 -->

<!-- csdn -->
<!-- 标签：DirectX,SharpDX,渲染 -->

<p>本文属于 <a href="https://blog.lindexi.com/post/WPF-%E4%BD%BF%E7%94%A8-SharpDx-%E6%B8%B2%E6%9F%93%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA.html">SharpDx 系列</a> 博客，建议从头开始读</p>

<p>本文的上一篇是 <a href="https://blog.lindexi.com/post/C-%E4%BB%8E%E9%9B%B6%E5%BC%80%E5%A7%8B%E5%86%99-SharpDx-%E5%BA%94%E7%94%A8-%E5%88%9D%E5%A7%8B%E5%8C%96dx%E4%BF%AE%E6%94%B9%E9%A2%9C%E8%89%B2.html">C# 从零开始写 SharpDx 应用 初始化dx修改颜色</a> 本文的代码将会在上一篇的代码上修改</p>

<p>在 SharpDx 里面可以通过两个方法进入全屏模式，一个是窗口进入全屏，另一个是交换链进入全屏</p>

<h2 id="窗口模式">窗口模式</h2>

<p>和普通的 WPF 窗口差不多，可以在 RenderForm 创建的时候设置进入全屏模式，全屏就是最大化的窗口同时去掉标题栏，隐藏任务栏</p>

<p>在 Windows 只要整个屏幕的所有像素被填充，那么任务栏将会自动隐藏</p>

<p>在 RenderForm 有一个属性是 IsFullscreen 如果单修改这个属性是没有用的，需要同时设置 AllowUserResizing 属性</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">_renderForm</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">RenderForm</span><span class="p">();</span>

            <span class="n">_renderForm</span><span class="p">.</span><span class="n">WindowState</span> <span class="p">=</span> <span class="n">FormWindowState</span><span class="p">.</span><span class="n">Maximized</span><span class="p">;</span>
            <span class="n">_renderForm</span><span class="p">.</span><span class="n">IsFullscreen</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="n">_renderForm</span><span class="p">.</span><span class="n">AllowUserResizing</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
</code></pre></div></div>

<p>这样就可以进入全屏，没有标题栏和任务栏</p>

<h2 id="设置透明窗口">设置透明窗口</h2>

<p>在窗口里面可以通过 TransparencyKey 设置某个颜色作为透明颜色，然后通过 AllowTransparency 设置支持透明</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            <span class="n">_renderForm</span><span class="p">.</span><span class="n">TransparencyKey</span> <span class="p">=</span> <span class="n">Color</span><span class="p">.</span><span class="n">Transparent</span><span class="p">;</span>
            <span class="n">_renderForm</span><span class="p">.</span><span class="n">AllowTransparency</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
</code></pre></div></div>

<p>这时画出的透明的颜色就是让窗口透明，透明的部分会命中到后面的元素</p>

<p>和 WPF 的全屏不相同的是，在 SharpDx 里面不会占用屏幕透明的内存，也就是透明部分不需要使用程序进程的内存</p>

<h2 id="交换链全屏">交换链全屏</h2>

<p>如果开启交换链的全屏，那么窗口透明将无法使用，使用交换链透明，在 Windows 的 DWM 将会整个屏幕的绘制交给程序，此时的程序绘制速度能更快</p>

<p>其他的应用有关渲染部分都不会执行，特别是其他的 dx 程序，这样程序可以用到很多的计算。用交换链的全屏可以做到更高的性能，但是在进入的时候都会因为屏幕显示切换出现黑色，现在很少有游戏使用交换链全屏</p>

<p>在上一篇说到的 InitializeDeviceResources 方法里面通过 CreateWithSwapChain 方法创建交换链的下方，可以设置全屏</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">InitializeDeviceResources</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">backBufferDesc</span> <span class="p">=</span>
                <span class="k">new</span> <span class="nf">ModeDescription</span><span class="p">(</span><span class="n">Width</span><span class="p">,</span> <span class="n">Height</span><span class="p">,</span> <span class="k">new</span> <span class="nf">Rational</span><span class="p">(</span><span class="m">60</span><span class="p">,</span> <span class="m">1</span><span class="p">),</span> <span class="n">Format</span><span class="p">.</span><span class="n">R8G8B8A8_UNorm</span><span class="p">);</span>

            <span class="kt">var</span> <span class="n">swapChainDesc</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SwapChainDescription</span>
            <span class="p">{</span>
                <span class="n">ModeDescription</span> <span class="p">=</span> <span class="n">backBufferDesc</span><span class="p">,</span>
                <span class="n">SampleDescription</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">SampleDescription</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">0</span><span class="p">),</span>
                <span class="n">Usage</span> <span class="p">=</span> <span class="n">Usage</span><span class="p">.</span><span class="n">RenderTargetOutput</span><span class="p">,</span>
                <span class="n">BufferCount</span> <span class="p">=</span> <span class="m">1</span><span class="p">,</span>
                <span class="n">OutputHandle</span> <span class="p">=</span> <span class="n">_renderForm</span><span class="p">.</span><span class="n">Handle</span><span class="p">,</span>
                <span class="n">IsWindowed</span> <span class="p">=</span> <span class="k">true</span>
            <span class="p">};</span>

            <span class="n">Device</span><span class="p">.</span><span class="nf">CreateWithSwapChain</span><span class="p">(</span><span class="n">DriverType</span><span class="p">.</span><span class="n">Hardware</span><span class="p">,</span> <span class="n">DeviceCreationFlags</span><span class="p">.</span><span class="n">None</span><span class="p">,</span> <span class="n">swapChainDesc</span><span class="p">,</span>
                <span class="k">out</span> <span class="n">_d3DDevice</span><span class="p">,</span> <span class="k">out</span> <span class="n">_swapChain</span><span class="p">);</span>

            <span class="c1">// 全屏</span>
            <span class="n">_swapChain</span><span class="p">.</span><span class="nf">SetFullscreenState</span><span class="p">(</span><span class="k">new</span> <span class="nf">RawBool</span><span class="p">(</span><span class="k">true</span><span class="p">),</span> <span class="k">null</span><span class="p">);</span>

            <span class="c1">// 忽略代码</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>通过 SetFullscreenState 可以将交换链的渲染信息输出到屏幕，在Windows Vista或更高版本中其实 独占 模式不会让整个程序用到所有的 GPU 资源，因为 GPU 是共享的，但是可以让程序用到更多的资源。清真的程序在其他程序进去全屏的时候，渲染策略会和这个程序最小化一样，不会做实际渲染</p>

<p><a href="https://blog.lindexi.com/post/WPF-%E4%BD%BF%E7%94%A8-SharpDx-%E6%B8%B2%E6%9F%93%E5%8D%9A%E5%AE%A2%E5%AF%BC%E8%88%AA.html">SharpDx 系列</a></p>

<p><a href="https://www.csharpcodi.com/csharp-examples/SharpDX.DXGI.SwapChain.SetFullscreenState(SharpDX.Mathematics.Interop.RawBool,%20SharpDX.DXGI.Output)/">SharpDX.DXGI.SwapChain.SetFullscreenState(SharpDX.Mathematics.Interop.RawBool, SharpDX.DXGI.Output) Example</a></p>

<p><a href="https://docs.microsoft.com/en-us/windows/desktop/direct3darticles/dxgi-best-practices#full-screen_issues?wt.mc_id=MVP">DirectX Graphics Infrastructure (DXGI) Best Practices - Windows applications</a></p>

<p><a href="http://sharpdx.org/wiki/class-library-api/dxgi/">DXGI API SharpDX</a></p>

:ET