I"<p>在 dotnet 里面，可以使用 Interlocked 进行原子命令更改 int 等的值，利用这个特性可以在一个固定足够长长度的数组里面，让多线程无锁等待写入值。因为没有锁的存在，无法保证读取时的安全，因此这样的集合只能被设计为只写的集合，只有在业务上完成了所有的写之后，才能作为可读的集合取出来</p>

<!--more-->

<!-- CreateTime:2020/10/12 14:40:23 -->

<p>这是在 <a href="https://www.newbe.pro/">newbe</a> 大佬的代码所看到的用法，这是他的一个实现 <a href="https://github.com/newbe36524/Newbe.Claptrap/blob/a187bac81652f9808a0f6cdc2916bbf6288e8ee3/src/Newbe.Claptrap/Tools/AutoFlushList.cs#">https://github.com/newbe36524/Newbe.Claptrap/blob/a187bac81652f9808a0f6cdc2916bbf6288e8ee3/src/Newbe.Claptrap/Tools/AutoFlushList.cs#</a> 尽管这个实现里面其实是有很多不安全的</p>

<p>一个安全和推荐的做法是在写入的时候禁止有任何的更改内部数组的长度的行为，同时在写入的时候禁止有任何的读取行为</p>

<p>这个快速无序仅写集合的原理是通过 Interlocked 原子让索引增加，此时每个线程进入写入方法时，都会触发一次索引增加，每次都拿到不同的索引值。而在初始化的时候在集合内容就创建了一个固定长度的数组，这样每次线程进入都会拿到不同的索引值，可以使用索引值对应到数组里面不同的下标，此时进行写入是安全的。当然也是仅写入安全，此时不能做读取</p>

<p>最简的实现方式如下</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">class</span> <span class="nc">ConcurrentWriteOnlyBag</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="k">public</span> <span class="nf">ConcurrentWriteOnlyBag</span><span class="p">(</span><span class="kt">int</span> <span class="n">capacity</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Capacity</span> <span class="p">=</span> <span class="n">capacity</span><span class="p">;</span>
            <span class="n">_buffer</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">capacity</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">int</span> <span class="n">Capacity</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Add</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">currentIndex</span> <span class="p">=</span> <span class="n">Interlocked</span><span class="p">.</span><span class="nf">Increment</span><span class="p">(</span><span class="k">ref</span> <span class="n">_currentIndex</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">currentIndex</span> <span class="p">&gt;</span> <span class="n">Capacity</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentOutOfRangeException</span><span class="p">();</span>
            <span class="p">}</span>

            <span class="n">_buffer</span><span class="p">[</span><span class="n">currentIndex</span><span class="p">]</span> <span class="p">=</span> <span class="k">value</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">readonly</span> <span class="n">T</span><span class="p">[]</span> <span class="n">_buffer</span><span class="p">;</span>

        <span class="k">private</span> <span class="kt">int</span> <span class="n">_currentIndex</span> <span class="p">=</span> <span class="p">-</span><span class="m">1</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>可以看到上面代码只有写入的功能，即使在写入完成之后，也没有方法去读取内部的 <code class="language-plaintext highlighter-rouge">_buffer</code> 数组的内容，因此可以在上面的类加上下面方法</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// 非线程安全</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// &lt;returns&gt;&lt;/returns&gt;</span>
        <span class="k">public</span> <span class="n">IReadOnlyCollection</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetReadOnlyCollection</span><span class="p">()</span> <span class="p">=&gt;</span> <span class="n">_buffer</span><span class="p">;</span>
</code></pre></div></div>

<p>需要注意的是 <code class="language-plaintext highlighter-rouge">GetReadOnlyCollection</code> 方法仅能在这个 ConcurrentWriteOnlyBag 写入完全完成之后才能使用，需要业务端保证这个行为，否则会出现读取的数据是不安全的数据，例如写入了一半或没有写入</p>

<p>上面代码的 GetReadOnlyCollection 方法是将整个内部 <code class="language-plaintext highlighter-rouge">_buffer</code> 全部返回，而不是将当前已写入的索引返回，因此在实际使用的时候，如果不会完全写满，还需要大家自己加上这部分的功能</p>

<p>因为这个集合没有任何的锁的存在，在多线程同时写入的时候的性能超级好</p>

<p>我有写了一些测试的代码，本文代码放在 <a href="https://github.com/lindexi/lindexi_gd/tree/3efbbbdd/JeekoheabeNurnurdawjerewear">github</a> 欢迎小伙伴访问</p>

<p>另外推荐一下 <a href="https://github.com/newbe36524/Newbe.Claptrap">newbe36524/Newbe.Claptrap</a> 这个有趣的库</p>

<p>同时推荐大家多线程工具集合：<a href="https://github.com/dotnet-campus/AsyncWorkerCollection">https://github.com/dotnet-campus/AsyncWorkerCollection</a> 开源库</p>

<p>在 <a href="https://github.com/dotnet-campus/AsyncWorkerCollection">https://github.com/dotnet-campus/AsyncWorkerCollection</a> 包含了 AsyncQueue DoubleBuffer DoubleBufferTask AsyncAutoResetEvent AsyncManualResetEvent LimitedRunningCountTask ExecuteOnceAwaiter 等的实现，详细请看</p>

<ul>
  <li><a href="https://blog.lindexi.com/post/dotnet-%E4%BD%BF%E7%94%A8-AsyncQueue-%E5%88%9B%E5%BB%BA%E9%AB%98%E6%80%A7%E8%83%BD%E5%86%85%E5%AD%98%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E9%98%9F%E5%88%97.html">dotnet 使用 AsyncQueue 创建高性能内存生产者消费者队列</a></li>
  <li><a href="https://blog.lindexi.com/post/dotnet-%E5%8F%8C%E7%BC%93%E5%AD%98%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E8%AE%BE%E8%AE%A1-%E4%B8%8B%E8%BD%BD%E5%BA%93%E7%9A%84%E6%96%87%E4%BB%B6%E5%86%99%E5%85%A5%E7%BC%93%E5%AD%98%E6%A1%86%E6%9E%B6.html">dotnet 双缓存数据结构设计 下载库的文件写入缓存框架</a></li>
  <li><a href="https://blog.lindexi.com/post/C-dotnet-%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7-AsyncAutoResetEvent-%E5%BC%82%E6%AD%A5%E7%AD%89%E5%BE%85%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95%E5%92%8C%E5%8E%9F%E7%90%86.html">C# dotnet 高性能多线程工具 AsyncAutoResetEvent 异步等待使用方法和原理</a></li>
  <li><a href="https://lindexi.gitee.io/post/C-dotnet-%E9%AB%98%E6%80%A7%E8%83%BD%E5%A4%9A%E7%BA%BF%E7%A8%8B%E5%B7%A5%E5%85%B7-ExecuteOnceAwaiter-%E5%8F%AA%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AC%A1%E7%9A%84%E4%BB%BB%E5%8A%A1.html">C# dotnet 高性能多线程工具 ExecuteOnceAwaiter 只执行一次的任务</a></li>
</ul>

:ET