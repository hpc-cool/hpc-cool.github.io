I"ÁN<p>åœ¨ WPF ä¸­ï¼Œå¦‚æœåœ¨æ²¡æœ‰å¼€å¯ Dispatcher çš„åå°çº¿ç¨‹é‡Œé¢åˆ›å»º WriteableBitmap å¯¹è±¡ï¼Œåœ¨ WriteableBitmap æ„é€ å‡½æ•°ä¼ å…¥åœ¨ä¸»çº¿ç¨‹åˆ›å»ºçš„ BitmapSource ä¹Ÿè®¸å°±ä¼šé”ä½ä¸»çº¿ç¨‹ã€‚æœ¬æ–‡å°†é€šè¿‡ WPF æ¡†æ¶æºä»£ç å‘Šè¯‰å¤§å®¶ä¸ºä»€ä¹ˆä¼šé”ä½ä¸»çº¿ç¨‹</p>

<!--more-->

<!-- CreateTime:2021/4/16 16:53:15 -->
<!-- æ ‡ç­¾ï¼šWPFï¼ŒWPFæºä»£ç  -->

<!-- å‘å¸ƒ -->

<p>è¿™æ˜¯åœ¨ WPF å¼€æºä»“åº“ä¸Šä¸€ä¸ªå°ä¼™ä¼´æŠ¥çš„ï¼Œè¯¦ç»†è¯·çœ‹ <a href="https://github.com/dotnet/wpf/issues/4396">WriteableBitmap hangs when source bitmap is rendered on other thread Â· Issue #4396 Â· dotnet/wpf</a></p>

<p>å¤ç°æ­¥éª¤ååˆ†ç®€å•ï¼Œåªéœ€è¦åœ¨åå°çº¿ç¨‹åˆ›å»ºå®Œæˆä¸€ä¸ª BitmapSource åˆ†åˆ«ä¼ å…¥ç»™ä¸»çº¿ç¨‹æ˜¾ç¤ºå’Œåå°çº¿ç¨‹åˆ›å»º WriteableBitmap å°±ä¼šé”ä½ä¸»çº¿ç¨‹ï¼Œæœ€ç®€å•çš„ä»£ç å¦‚ä¸‹</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>				<span class="n">Task</span><span class="p">.</span><span class="nf">Run</span><span class="p">(()</span> <span class="p">=&gt;</span>
				<span class="p">{</span>
					<span class="kt">var</span> <span class="n">image</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BitmapImage</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">fileName</span><span class="p">));</span>

					<span class="n">image</span><span class="p">.</span><span class="nf">Freeze</span><span class="p">();</span>  <span class="c1">// locks the bitmap source, so other threads can access</span>

					<span class="n">Dispatcher</span><span class="p">.</span><span class="nf">InvokeAsync</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Image</span><span class="p">.</span><span class="n">Source</span> <span class="p">=</span> <span class="p">(</span><span class="n">BitmapSource</span><span class="p">)</span> <span class="n">image</span><span class="p">);</span>
					<span class="c1">//Thread.Sleep(10);   // WPF needs time to render the bitmap. During this period, creating a WriteableBitmap makes the program hang.</span>

					<span class="n">_</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WriteableBitmap</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
				<span class="p">});</span>
</code></pre></div></div>

<p>ä¸Šé¢ä»£ç çš„ Image æ˜¯ä¸€ä¸ªåœ¨ XAML å®šä¹‰çš„æ§ä»¶</p>

<div class="language-xml highlighter-rouge"><div class="highlight"><pre class="highlight"><code>			<span class="nt">&lt;Image</span> <span class="na">x:Name=</span><span class="s">"Image"</span><span class="nt">/&gt;</span>
</code></pre></div></div>

<p>ä¸Šé¢çš„ fileName æ˜¯ä¸€ä¸ªæ–‡ä»¶çš„è·¯å¾„ã€‚è¯¦ç»†çš„æµ‹è¯•ä»£ç è¯·çœ‹ <a href="https://github.com/lindexi/lindexi_gd/tree/82c1dc09816d7a15214a167cae78f215a3393d6c/BitmapSourceTest">https://github.com/SetTrend/BitmapSourceTest</a></p>

<p>ä¸ºä»€ä¹ˆè¿™ä¸ªåå°çº¿ç¨‹å’Œä¸»çº¿ç¨‹ä¼šç›¸äº’ç­‰å¾…ï¼ŸåŸå› æ˜¯åœ¨åå°çº¿ç¨‹åˆ›å»º WriteableBitmap æ—¶ï¼Œä¼šè¿›å…¥ <code class="language-plaintext highlighter-rouge">WriteableBitmap.InitFromBitmapSource</code> æ–¹æ³•ï¼Œåœ¨è¿™ä¸ªæ–¹æ³•é‡Œé¢è·å–äº†ä¸€ä¸ªä¸»çº¿ç¨‹åç»­å°†ä¼šç­‰å¾…çš„é”ã€‚ç„¶è€Œåå°çº¿ç¨‹åç»­éœ€è¦ç­‰å¾…ä¸»çº¿ç¨‹è¿”å›ï¼Œæ‰èƒ½å®Œæˆåˆ›å»ºå›¾ç‰‡ï¼Œå› æ­¤ä¸»çº¿ç¨‹åœ¨ç­‰å¾…åå°çº¿ç¨‹çš„é”è€Œåå°çº¿ç¨‹åœ¨ç­‰å¾…ä¸»çº¿ç¨‹è¿”å›ï¼Œä¸¤ä¸ªçº¿ç¨‹åœ¨ç­‰å¾…</p>

<p>é€šè¿‡ WPF ä»“åº“çš„æºä»£ç å¯ä»¥çœ‹åˆ° <code class="language-plaintext highlighter-rouge">WriteableBitmap.InitFromBitmapSource</code> æ–¹æ³•çš„å®ç°å¦‚ä¸‹</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">public</span> <span class="k">sealed</span> <span class="k">class</span> <span class="nc">WriteableBitmap</span> <span class="p">:</span> <span class="n">BitmapSource</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">void</span> <span class="nf">InitFromBitmapSource</span><span class="p">(</span>
            <span class="n">BitmapSource</span> <span class="n">source</span>
            <span class="p">)</span>
        <span class="p">{</span>
        	<span class="c1">// Ignore code</span>
        	 <span class="n">_syncObject</span> <span class="p">=</span> <span class="n">source</span><span class="p">.</span><span class="n">SyncObject</span><span class="p">;</span>
            <span class="k">lock</span> <span class="p">(</span><span class="n">_syncObject</span><span class="p">)</span>
            <span class="p">{</span>
            	<span class="c1">// Ignore code</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>ä¹Ÿå°±æ˜¯è¯´åœ¨åå°çº¿ç¨‹å°†ä¼šæ‹¿åˆ°åˆ›å»º WriteableBitmap æ„é€ å‡½æ•°ä¼ å…¥çš„ BitmapSource çš„ SyncObject å¯¹è±¡ä½œä¸ºé”ã€‚å¯¹åº”æµ‹è¯•ä»£ç çš„ image å˜é‡çš„ SyncObject å¯¹è±¡å…ˆè¢«åå°çº¿ç¨‹è·å–ï¼Œç„¶ååœ¨ä¸»çº¿ç¨‹æ¸²æŸ“æ—¶ï¼Œä¹Ÿéœ€è¦ç”¨åˆ°è¿™ä¸ªé”ï¼Œåœ¨ä¸»çº¿ç¨‹çš„å †æ ˆå¦‚ä¸‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.UpdateBitmapSourceResource(System.Windows.Media.Composition.DUCE.Channel channel = {System.Windows.Media.Composition.DUCE.Channel}, bool skipOnChannelCheck)
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.UpdateResource(System.Windows.Media.Composition.DUCE.Channel channel, bool skipOnChannelCheck)
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.AddRefOnChannelCore(System.Windows.Media.Composition.DUCE.Channel channel = {System.Windows.Media.Composition.DUCE.Channel})
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(System.Windows.Media.Composition.DUCE.Channel channel)
 	PresentationCore.dll!System.Windows.Media.RenderData.System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(System.Windows.Media.Composition.DUCE.Channel channel = {System.Windows.Media.Composition.DUCE.Channel})
 	PresentationCore.dll!System.Windows.UIElement.RenderContent(System.Windows.Media.RenderContext ctx, bool isOnChannel)
 	PresentationCore.dll!System.Windows.Media.Visual.UpdateContent(System.Windows.Media.RenderContext ctx = {System.Windows.Media.RenderContext}, System.Windows.Media.VisualProxyFlags flags, bool isOnChannel)
 	PresentationCore.dll!System.Windows.Media.Visual.RenderRecursive(System.Windows.Media.RenderContext ctx = {System.Windows.Media.RenderContext})
</code></pre></div></div>

<p>åœ¨ä¸»çº¿ç¨‹æ¸²æŸ“å›¾ç‰‡ï¼Œéœ€è¦åœ¨ <code class="language-plaintext highlighter-rouge">BitmapSource.UpdateBitmapSourceResource</code> æ–¹æ³•é‡Œé¢è·å–é”ï¼Œè¯·çœ‹ä»£ç </p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>     <span class="k">public</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BitmapSource</span> <span class="p">:</span> <span class="n">ImageSource</span><span class="p">,</span> <span class="n">DUCE</span><span class="p">.</span><span class="n">IResource</span>
     <span class="p">{</span>
        <span class="k">internal</span> <span class="k">virtual</span> <span class="k">void</span> <span class="nf">UpdateBitmapSourceResource</span><span class="p">(</span><span class="n">DUCE</span><span class="p">.</span><span class="n">Channel</span> <span class="n">channel</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">skipOnChannelCheck</span><span class="p">)</span>
        <span class="p">{</span>
                <span class="c1">// Ignore code</span>
                <span class="c1">// We may end up loading in the bitmap bits so it's necessary to take the sync lock here.</span>
                <span class="k">lock</span> <span class="p">(</span><span class="n">_syncObject</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">channel</span><span class="p">.</span><span class="nf">SendCommandBitmapSource</span><span class="p">(</span>
                        <span class="n">_duceResource</span><span class="p">.</span><span class="nf">GetHandle</span><span class="p">(</span><span class="n">channel</span><span class="p">),</span>
                        <span class="n">DUCECompatiblePtr</span>
                        <span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
     <span class="p">}</span>
</code></pre></div></div>

<p>ä¸Šé¢ä»£ç çš„ <code class="language-plaintext highlighter-rouge">_syncObject</code> å’Œåœ¨åå°çº¿ç¨‹è·å–çš„ SyncObject æ˜¯ç›¸åŒçš„å¯¹è±¡ï¼Œå› æ­¤ä¸»çº¿ç¨‹éœ€è¦ç­‰å¾…åå°çº¿ç¨‹ã€‚ä½†æ˜¯åå°çº¿ç¨‹åœ¨æ‰§è¡Œåˆ° <code class="language-plaintext highlighter-rouge">MediaSystem.Startup</code> æ–¹æ³•æ—¶ï¼Œå°±éœ€è¦ç­‰å¾…ä¸»çº¿ç¨‹è¿”å›ï¼Œåå°çº¿ç¨‹è°ƒç”¨å †æ ˆå¦‚ä¸‹</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code> 	[Manage to Native]	
 	PresentationCore.dll!System.Windows.Media.MediaSystem.Startup(System.Windows.Media.MediaContext mc = {System.Windows.Media.MediaContext})
 	PresentationCore.dll!System.Windows.Media.MediaContext.MediaContext(System.Windows.Threading.Dispatcher dispatcher = {System.Windows.Threading.Dispatcher})
 	PresentationCore.dll!System.Windows.Media.MediaContext.From(System.Windows.Threading.Dispatcher dispatcher)
 	PresentationCore.dll!System.Windows.Media.Imaging.WriteableBitmap.SubscribeToCommittingBatch()
 	PresentationCore.dll!System.Windows.Media.Imaging.WriteableBitmap.Unlock()
 	PresentationCore.dll!System.Windows.Media.Imaging.WriteableBitmap.InitFromBitmapSource(System.Windows.Media.Imaging.BitmapSource source)
 	PresentationCore.dll!System.Windows.Media.Imaging.WriteableBitmap.WriteableBitmap(System.Windows.Media.Imaging.BitmapSource source)
&gt;	BitmapSourceTest.dll!BitmapSourceTest.MainWindow.ProcessImageAsync(string filePath)
 	BitmapSourceTest.dll!BitmapSourceTest.MainWindow.BrowseFile_Click.AnonymousMethod__0()
 	System.Private.CoreLib.dll!System.Threading.Tasks.Task.InnerInvoke()
 	System.Private.CoreLib.dll!System.Threading.Tasks.Task..cctor.AnonymousMethod__277_0(object obj)
 	System.Private.CoreLib.dll!System.Threading.ExecutionContext.RunFromThreadPoolDispatchLoop(System.Threading.Thread threadPoolThread = {System.Threading.Thread}, System.Threading.ExecutionContext executionContext, System.Threading.ContextCallback callback, object state)
 	System.Private.CoreLib.dll!System.Threading.Tasks.Task.ExecuteWithThreadLocal(ref System.Threading.Tasks.Task currentTaskSlot = Id = 189, Status = Running, Method = "Void &lt;BrowseFile_Click&gt;b__0()", System.Threading.Thread threadPoolThread)
 	System.Private.CoreLib.dll!System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread threadPoolThread)
 	System.Private.CoreLib.dll!System.Threading.Tasks.Task.ExecuteFromThreadPool(System.Threading.Thread threadPoolThread)
 	System.Private.CoreLib.dll!System.Threading.ThreadPoolWorkQueue.Dispatch()
 	System.Private.CoreLib.dll!System.Threading._ThreadPoolWaitCallback.PerformWaitCallback()
</code></pre></div></div>

<p>å¯ä»¥ä»ä¸Šé¢ä»£ç çœ‹åˆ°ï¼Œä¸»çº¿ç¨‹åœ¨ç­‰å¾…åå°çº¿ç¨‹çš„é”ï¼Œè€Œåå°çº¿ç¨‹éœ€è¦ç­‰å¾…ä¸»çº¿ç¨‹è¿”å›æ‰èƒ½é‡Šæ”¾é”</p>

<p>å…¶å®åœ¨åå°çº¿ç¨‹åˆ›å»ºå›¾ç‰‡ï¼ŒåŒæ—¶åˆ›å»ºçš„å›¾ç‰‡çš„å‚æ•°è¿˜æ˜¯åœ¨ä¸»çº¿ç¨‹ä½¿ç”¨çš„å›¾ç‰‡ï¼Œè¿™æ ·çš„é€»è¾‘ä¸å¤šï¼Œæ›´å¤šä½¿ç”¨çš„æ˜¯åªåœ¨åå°çº¿ç¨‹åˆ›å»ºå›¾ç‰‡ç„¶åé€šè¿‡ Freeze ç»™åˆ°ä¸»çº¿ç¨‹ç”¨æ¥è§£å†³æ€§èƒ½é—®é¢˜ã€‚ä½†ä¸Šé¢æµ‹è¯•ä»£ç çš„é€»è¾‘ä¹Ÿä¸ç®—å‡ºé”™ï¼Œå¯ä»¥ç®— WPF çš„å·²çŸ¥å‘ã€‚ä¹Ÿè®¸æˆ‘ä¼šå°è¯•å»ä¿®å¤è¿™ä¸ªé—®é¢˜</p>

<p>å¦‚æœä¸æ›´æ”¹ WPF æ¡†æ¶ä»£ç ï¼Œé‚£ä¹ˆä¸€ä¸ªå°è¯•è§£å†³çš„æ–¹æ³•æ˜¯åœ¨åå°çº¿ç¨‹å¼€å¯ UI çº¿ç¨‹ï¼Œé¢„çƒ­ä¸€ä¸‹æ¸²æŸ“ã€‚é¢„çƒ­ç”¨æ¥è§£å†³åå°çº¿ç¨‹åˆ›å»º MediaContext éœ€è¦ç­‰å¾…ä¸»çº¿ç¨‹ï¼Œé€šè¿‡é¢„å…ˆåˆ›å»ºï¼Œæ­¤æ—¶å¯ä»¥ç­‰å¾…åˆ°ä¸»çº¿ç¨‹ï¼Œå¦‚ä¸‹é¢ä»£ç </p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>				<span class="n">Dispatcher</span> <span class="n">backgroundDispatcher</span> <span class="p">=</span> <span class="k">null</span><span class="p">!;</span>
				<span class="n">AutoResetEvent</span> <span class="n">resetEvent</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">AutoResetEvent</span><span class="p">(</span><span class="k">false</span><span class="p">);</span>
				<span class="n">Thread</span> <span class="n">thread</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Thread</span><span class="p">(()</span> <span class="p">=&gt;</span>
				<span class="p">{</span>
					<span class="n">backgroundDispatcher</span> <span class="p">=</span> <span class="n">Dispatcher</span><span class="p">.</span><span class="n">CurrentDispatcher</span><span class="p">;</span>
					<span class="n">resetEvent</span><span class="p">.</span><span class="nf">Set</span><span class="p">();</span>
					<span class="n">Dispatcher</span><span class="p">.</span><span class="nf">Run</span><span class="p">();</span>
				<span class="p">});</span>
				<span class="n">thread</span><span class="p">.</span><span class="nf">SetApartmentState</span><span class="p">(</span><span class="n">ApartmentState</span><span class="p">.</span><span class="n">STA</span><span class="p">);</span>
				<span class="n">thread</span><span class="p">.</span><span class="n">IsBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
				<span class="n">thread</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

				<span class="n">resetEvent</span><span class="p">.</span><span class="nf">WaitOne</span><span class="p">();</span>

				<span class="c1">// To Create the MediaContext which is thread static</span>
				<span class="n">backgroundDispatcher</span><span class="p">.</span><span class="nf">InvokeAsync</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="k">new</span> <span class="nf">WriteableBitmap</span><span class="p">(</span><span class="m">1</span><span class="p">,</span> <span class="m">1</span><span class="p">,</span> <span class="m">96</span><span class="p">,</span> <span class="m">96</span><span class="p">,</span> <span class="n">PixelFormats</span><span class="p">.</span><span class="n">Bgr32</span><span class="p">,</span> <span class="k">null</span><span class="p">));</span>

				<span class="n">backgroundDispatcher</span><span class="p">.</span><span class="nf">InvokeAsync</span><span class="p">(()</span> <span class="p">=&gt;</span>
				<span class="p">{</span>
					<span class="kt">var</span> <span class="n">image</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">BitmapImage</span><span class="p">(</span><span class="k">new</span> <span class="nf">Uri</span><span class="p">(</span><span class="n">openDialog</span><span class="p">.</span><span class="n">FileName</span><span class="p">));</span>

					<span class="n">image</span><span class="p">.</span><span class="nf">Freeze</span><span class="p">();</span> <span class="c1">// locks the bitmap source, so other threads can access</span>

					<span class="n">Dispatcher</span><span class="p">.</span><span class="nf">InvokeAsync</span><span class="p">(()</span> <span class="p">=&gt;</span> <span class="n">Image</span><span class="p">.</span><span class="n">Source</span> <span class="p">=</span> <span class="p">(</span><span class="n">BitmapSource</span><span class="p">)</span> <span class="n">image</span><span class="p">);</span>

					<span class="n">_</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">WriteableBitmap</span><span class="p">(</span><span class="n">image</span><span class="p">);</span>
				<span class="p">});</span>
</code></pre></div></div>

<p>ä»£ç æ”¾åœ¨ <a href="https://github.com/lindexi/lindexi_gd/tree/0a8ac8dd9a61599dfa8624f73dfd22fd4b1bc539/BitmapSourceTest">github</a> æ¬¢è¿å°ä¼™ä¼´è®¿é—®</p>

<!-- 
6713

Why the background task will dead lock? Because the background task will get the lock in `WriteableBitmap.InitFromBitmapSource` method.

```csharp
    public sealed class WriteableBitmap : BitmapSource
    {
        private void InitFromBitmapSource(
            BitmapSource source
            )
        {
        	// Ignore code
        	 _syncObject = source.SyncObject;
            lock (_syncObject)
            {
            	// Ignore code
            }
        }
    }
```

And the `source` is a TransformedBitmap which was created in `ProcessImageAsync` method and running in background task.

```csharp
// The Demo code
		private void ProcessImageAsync(string filePath)
		{
			TransformedBitmap tb = new TransformedBitmap(new BitmapImage(new Uri(filePath)), new RotateTransform(90));

			CopyBitmapSourceToUi(tb);

			_ = new WriteableBitmap(tb);
		}
```

But the `source.SyncObject` will be used in main thread when Render.

```
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.UpdateBitmapSourceResource(System.Windows.Media.Composition.DUCE.Channel channel = {System.Windows.Media.Composition.DUCE.Channel}, bool skipOnChannelCheck)
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.UpdateResource(System.Windows.Media.Composition.DUCE.Channel channel, bool skipOnChannelCheck)
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.AddRefOnChannelCore(System.Windows.Media.Composition.DUCE.Channel channel = {System.Windows.Media.Composition.DUCE.Channel})
 	PresentationCore.dll!System.Windows.Media.Imaging.BitmapSource.System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(System.Windows.Media.Composition.DUCE.Channel channel)
 	PresentationCore.dll!System.Windows.Media.RenderData.System.Windows.Media.Composition.DUCE.IResource.AddRefOnChannel(System.Windows.Media.Composition.DUCE.Channel channel = {System.Windows.Media.Composition.DUCE.Channel})
 	PresentationCore.dll!System.Windows.UIElement.RenderContent(System.Windows.Media.RenderContext ctx, bool isOnChannel)
 	PresentationCore.dll!System.Windows.Media.Visual.UpdateContent(System.Windows.Media.RenderContext ctx = {System.Windows.Media.RenderContext}, System.Windows.Media.VisualProxyFlags flags, bool isOnChannel)
 	PresentationCore.dll!System.Windows.Media.Visual.RenderRecursive(System.Windows.Media.RenderContext ctx = {System.Windows.Media.RenderContext})
```

The main thread will use the same SyncObject in BitmapSource.UpdateBitmapSourceResource

```csharp
     public abstract class BitmapSource : ImageSource, DUCE.IResource
     {
        internal virtual void UpdateBitmapSourceResource(DUCE.Channel channel, bool skipOnChannelCheck)
        {
                // Ignore code
                // We may end up loading in the bitmap bits so it's necessary to take the sync lock here.
                lock (_syncObject)
                {
                    channel.SendCommandBitmapSource(
                        _duceResource.GetHandle(channel),
                        DUCECompatiblePtr
                        );
                }
            }
        }
     }
```


The main thread will waitting the `_syncObject` which be used in background task in `WriteableBitmap.InitFromBitmapSource` method.

But the background task now waitting the main thread in `MediaSystem.Startup`. So the main thread wait background task to release the `_syncObject` lock and the background task wait main thread. -->

<p>å½“å‰çš„ WPF åœ¨ <a href="https://github.com/dotnet/wpf">https://github.com/dotnet/wpf</a> å®Œå…¨å¼€æºï¼Œä½¿ç”¨å‹å¥½çš„ MIT åè®®ï¼Œæ„å‘³ç€å…è®¸ä»»ä½•äººä»»ä½•ç»„ç»‡å’Œä¼ä¸šä»»æ„å¤„ç½®ï¼ŒåŒ…æ‹¬ä½¿ç”¨ï¼Œå¤åˆ¶ï¼Œä¿®æ”¹ï¼Œåˆå¹¶ï¼Œå‘è¡¨ï¼Œåˆ†å‘ï¼Œå†æˆæƒï¼Œæˆ–è€…é”€å”®ã€‚åœ¨ä»“åº“é‡Œé¢åŒ…å«äº†å®Œå…¨çš„æ„å»ºé€»è¾‘ï¼Œåªéœ€è¦æœ¬åœ°çš„ç½‘ç»œè¶³å¤Ÿå¥½ï¼ˆå› ä¸ºéœ€è¦ä¸‹è½½ä¸€å †æ„å»ºå·¥å…·ï¼‰ï¼Œå³å¯è¿›è¡Œæœ¬åœ°æ„å»º</p>

:ET