I"<p>我在写小说阅读器，把每个打开的文件的内容读到内存，因为小说都很小，所以放在内存不怕太大，但是我如果打开了一本小说，再打开一本，我不会把先打开的小说的内容清除掉，在内存。所以一旦我打开多小说的时候，内存就会用比较多，这样觉得不好，不过垃圾wr给我们一个事件，这个我会在下面说。</p>

<!--more-->

<!-- CreateTime:2019/9/2 12:57:38 -->

<div id="toc"></div>

<p>我们很多应用会在前台用很多资源，例如我们的界面，在转入后台可以清理很多资源，如果判断用户不是马上就转回的，我们可以用新的<code class="language-plaintext highlighter-rouge">EnteredBackground</code>使用简单。在我的小说里面有写，我来看看我是怎么写。</p>

<p>在我们的App()</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">public</span> <span class="nf">App</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">this</span><span class="p">.</span><span class="nf">InitializeComponent</span><span class="p">();</span>
            <span class="k">this</span><span class="p">.</span><span class="n">Suspending</span> <span class="p">+=</span> <span class="n">OnSuspending</span><span class="p">;</span>

            <span class="n">EnteredBackground</span> <span class="p">+=</span> <span class="n">App_EnteredBackground</span><span class="p">;</span>
            <span class="n">LeavingBackground</span> <span class="p">+=</span> <span class="n">App_LeavingBackground</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="nf">App_LeavingBackground</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">LeavingBackgroundEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//应用离开后台</span>
            <span class="n">_areBackground</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">void</span> <span class="nf">App_EnteredBackground</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EnteredBackgroundEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//应用进入后台</span>
            <span class="n">_areBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="kt">bool</span> <span class="n">_areBackground</span><span class="p">;</span>


</code></pre></div></div>

<p>如果你应用没有EnteredBackground ，更新sdk 14393</p>

<p>如果安装了，可以修改你的文件<code class="language-plaintext highlighter-rouge">&lt;TargetPlatformVersion&gt;10.0.14393.0&lt;/TargetPlatformVersion&gt;</code></p>

<p><img src="http://img.blog.csdn.net/20160913190120214" alt="这里写图片描述" /></p>

<p>我们判断在我们进入后台清理我们的内存，因为小说经常不是后台就不用，我们就把我们现在使用的小说打开，其他打开小说放在内存资源全删，很简单，但是我们看官方建议是不<code class="language-plaintext highlighter-rouge">GC.Collect();</code></p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">App_EnteredBackground</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">EnteredBackgroundEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//应用进入后台</span>
            <span class="n">_areBackground</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
            <span class="c1">//清理</span>
            <span class="kt">var</span> <span class="n">account</span> <span class="p">=</span> <span class="n">AccountGoverment</span><span class="p">.</span><span class="n">View</span><span class="p">.</span><span class="n">Account</span><span class="p">;</span><span class="c1">//我们把所有的用户的放在用户管理</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">account</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span><span class="c1">//我们把我们现在打开的小说除掉，其他都清空</span>
                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">temp</span> <span class="k">in</span> <span class="n">account</span><span class="p">.</span><span class="n">File</span><span class="p">.</span><span class="nf">Where</span><span class="p">(</span><span class="n">temp</span> <span class="p">=&gt;</span> <span class="n">temp</span> <span class="p">!=</span> <span class="n">AccountGoverment</span><span class="p">.</span><span class="n">View</span><span class="p">.</span><span class="n">File</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="c1">//AccountGoverment.View.File我们打开的小说</span>
                    <span class="c1">//account.File 所有小说</span>
                    <span class="n">temp</span><span class="p">.</span><span class="n">Str</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
                    <span class="c1">//我们会在加载的时候，点击小说，EaddressModel.Read()</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>我们对于内存，还有在我们使用缓存，判断我们应用使用内存，垃圾wr给我们两个事件，需要我们用sdk 14393，我觉得垃圾wr这样不好，才半年就改</p>

<p><code class="language-plaintext highlighter-rouge">MemoryManager</code>给我们几个属性，<code class="language-plaintext highlighter-rouge">AppMemoryUsage</code> 获取应用程序当前的内存使用率, <code class="language-plaintext highlighter-rouge">AppMemoryUsageLevel</code> 获取应用程序当前的内存使用率级别,<code class="language-plaintext highlighter-rouge">AppMemoryUsageLimit</code> 获取应用程序当前的内存使用率限制,都是只读，我们可以获取这些值来得到我们应用是不是占用太多内存。</p>

<p><code class="language-plaintext highlighter-rouge">AppMemoryUsageLimitChanging</code>应用限制最大内存，在我们应用转入后台，我们的内存限制就会变化，然而还有很多诡异的也会让我们内存限制变化，我们可以根据内存变化，清理缓存</p>

<p><code class="language-plaintext highlighter-rouge">AppMemoryUsageIncreased</code>我们在我们开始缓存需要我们的内存应用等级，这个事件是内存使用等级，假如我们的内存等级从小到大，那么发生，一旦发生我们就要检查我们是否清理</p>

<p><code class="language-plaintext highlighter-rouge">AppMemoryUsageDecreased</code>我们应用内存等级下降，在我们使用内存从大到小使用，这个在我们清理很多缓存可以让我们知道不用清理，一般用是在<code class="language-plaintext highlighter-rouge">AppMemoryUsageIncreased</code> 有个任务CleanTask，把我们的缓存清理，然后我们有个bool，一旦<code class="language-plaintext highlighter-rouge">AppMemoryUsageDecreased</code>我们就设为true，那么我们的CleanTask判断true就停下。</p>

<p>源代码：https://github.com/lindexi/NovelRead</p>

:ET