I"õ<p>æˆ‘åœ¨å†™ä¸€ä¸ªç®€å•çš„æ–‡ä»¶æœåŠ¡å™¨ï¼Œæƒ³è¦ç”¨æ¥åšå®¢æˆ·ç«¯ä¸‹è½½å™¨çš„æµ‹è¯•æœåŠ¡å™¨ï¼Œä½†æ˜¯è¿”å›çš„æ–¹æ³•æç¤º ObjectDisposedException: Cannot access a disposed object. Object name: â€˜Cannot access a closed file.â€™ åŸå› æ˜¯æˆ‘çš„æ–‡ä»¶è¢«é‡Šæ”¾</p>

<!--more-->

<!-- CreateTime:2020/1/30 16:55:33 -->

<p>åœ¨å¼€å‘ç«¯è®¿é—®é“¾æ¥å¯ä»¥è¿”å›ä¸€äº›æç¤ºï¼Œå¦‚æˆ‘ä½¿ç”¨ä¸‹é¢ä»£ç åšä¸€ä¸ªæ–‡ä»¶ä¸‹è½½æœåŠ¡å™¨</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    [ApiController]
    public class FileDownloadController:ControllerBase
    {
        [HttpGet("download")]
        public IActionResult Download()
        {
            var file = @"F:\win10.14926.1000.160910-1529.RS_PRERELEASE_CLIENTPRO_OEMRET_X64FRE_ZH-CN.ISO";

            using var fileStream = new FileStream(file, FileMode.Open);

            return File(fileStream, MimeType, "win10.14926.1000.160910-1529.RS_PRERELEASE_CLIENTPRO_OEMRET_X64FRE_ZH-CN.ISO");
        }

        private const string MimeType = "application/octet-stream";
    }
</code></pre></div></div>

<p>ä¸Šé¢ä»£ç æˆ‘è¿”å›ä¸€ä¸ªå¤§çš„æ–‡ä»¶ï¼Œä½†æ˜¯è®¿é—® <code class="language-plaintext highlighter-rouge">https://localhost:5001/download</code> ä¼šæç¤ºæ–‡ä»¶è¢«é‡Šæ”¾</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>ObjectDisposedException: Cannot access a disposed object.
Object name: 'Cannot access a closed file.'.
System.IO.FileStream.BeginRead(byte[] array, int offset, int numBytes, AsyncCallback callback, object state)

ObjectDisposedException: Cannot access a disposed object. Object name: 'Cannot access a closed file.'.
System.IO.FileStream.BeginRead(byte[] array, int offset, int numBytes, AsyncCallback callback, object state)
System.IO.Stream+&lt;&gt;c.&lt;BeginEndReadAsync&gt;b__48_0(Stream stream, ReadWriteParameters args, AsyncCallback callback, object state)
System.Threading.Tasks.TaskFactory&lt;TResult&gt;.FromAsyncTrim&lt;TInstance, TArgs&gt;(TInstance thisRef, TArgs args, Func&lt;TInstance, TArgs, AsyncCallback, object, IAsyncResult&gt; beginMethod, Func&lt;TInstance, IAsyncResult, TResult&gt; endMethod)
System.IO.Stream.BeginEndReadAsync(byte[] buffer, int offset, int count)
System.IO.FileStream.ReadAsync(byte[] buffer, int offset, int count, CancellationToken cancellationToken)
Microsoft.AspNetCore.Http.StreamCopyOperationInternal.CopyToAsync(Stream source, Stream destination, Nullable&lt;long&gt; count, int bufferSize, CancellationToken cancel)
Microsoft.AspNetCore.Mvc.Infrastructure.FileResultExecutorBase.WriteFileAsync(HttpContext context, Stream fileStream, RangeItemHeaderValue range, long rangeLength)
Microsoft.AspNetCore.Mvc.Infrastructure.FileStreamResultExecutor.ExecuteAsync(ActionContext context, FileStreamResult result)
Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeNextResultFilterAsync&gt;g__Awaited|29_0&lt;TFilter, TFilterAsync&gt;(ResourceInvoker invoker, Task lastTask, State next, Scope scope, object state, bool isCompleted)
Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.Rethrow(ResultExecutedContextSealed context)
Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.ResultNext&lt;TFilter, TFilterAsync&gt;(ref State next, ref Scope scope, ref object state, ref bool isCompleted)
Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.InvokeResultFilters()
Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeFilterPipelineAsync&gt;g__Awaited|19_0(ResourceInvoker invoker, Task lastTask, State next, Scope scope, object state, bool isCompleted)
Microsoft.AspNetCore.Mvc.Infrastructure.ResourceInvoker.&lt;InvokeAsync&gt;g__Awaited|17_0(ResourceInvoker invoker, Task task, IDisposable scope)
Microsoft.AspNetCore.Routing.EndpointMiddleware.&lt;Invoke&gt;g__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)
Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)
Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)
</code></pre></div></div>

<p>å› ä¸ºæˆ‘åœ¨è¿”å›ä¹‹å‰ç”¨äº† using ä¹Ÿå°±æ˜¯é‡Šæ”¾ FileStream èµ„æº</p>

<p>åœ¨ C# 8.0 æä¾›äº†è®© using æ”¾åœ¨å¯¹è±¡åˆ›å»ºä¹‹å‰ï¼Œå¯ä»¥åœ¨å¯¹è±¡ä½œç”¨èŒƒå›´ç»“æŸè‡ªåŠ¨é‡Šæ”¾å¯¹è±¡ï¼Œä¹Ÿå°±æ˜¯ä¸‹é¢ä»£ç æ˜¯ç›¸åŒçš„</p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>            using var fileStream = new FileStream(file, FileMode.Open);

            return File(fileStream, MimeType, "win10.14926.1000.160910-1529.RS_PRERELEASE_CLIENTPRO_OEMRET_X64FRE_ZH-CN.ISO");

// å’Œè¿™ä¸ªä»£ç æ˜¯ç›¸åŒçš„

            using (var fileStream = new FileStream(file, FileMode.Open))
            {
                return File(fileStream, MimeType, "win10.14926.1000.160910-1529.RS_PRERELEASE_CLIENTPRO_OEMRET_X64FRE_ZH-CN.ISO");
            }
</code></pre></div></div>

<p>åœ¨è¿”å› File æ–¹æ³•ä¹‹åå°†ä¼šé‡Šæ”¾ fileStream ä½†æ˜¯åœ¨ asp dotnet core è¿”å›ç»™å®¢æˆ·ç«¯çš„ä¿¡æ¯æ˜¯åœ¨ Download æ–¹æ³•ä¹‹åï¼Œä¹Ÿå°±æ˜¯åœ¨ç»“æŸ Download æ–¹æ³•ä¹‹åè¯»å– FileStream å†…å®¹ï¼Œè¯»å–ä¸€ä¸ªè¢«é‡Šæ”¾çš„ FileStream ä¼šæç¤ºä¸èƒ½è¯»å–æ–‡ä»¶</p>

<p>è§£å†³æ–¹æ³•å°±æ˜¯å»æ‰ using å°±å¯ä»¥äº†</p>

<p>æœ€ç®€å•è¿”å›ä¸€ä¸ªæ–‡ä»¶çš„æ–¹æ³•æ˜¯é€šè¿‡ PhysicalFile æ–¹æ³•ï¼Œè¯·çœ‹ä»£ç </p>

<div class="language-plaintext highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        [HttpGet("download")]
        public IActionResult Download()
        {
            var file = @"F:\win10.14926.1000.160910-1529.RS_PRERELEASE_CLIENTPRO_OEMRET_X64FRE_ZH-CN.ISO";

            return PhysicalFile(file, MimeType);
        }

        private const string MimeType = "application/octet-stream";
</code></pre></div></div>

<p>åœ¨ PhysicalFile å¤„ç†äº†æ–‡ä»¶çš„è‡ªåŠ¨é‡Šæ”¾ç­‰é—®é¢˜ï¼Œä½¿ç”¨å¾ˆç®€å•ï¼Œä½†æ˜¯æˆ‘å‘ç°è¿™è´§å­˜åœ¨å†…å­˜æ³„æ¼ï¼Œè¯·çœ‹ <a href="https://github.com/dotnet/aspnetcore/issues/13535">Maybe PhysicalFile will be memory leak</a></p>

<p>ä½¿ç”¨ PhysicalFile ç­‰æ–¹æ³•å¯ä»¥å¿«é€Ÿå®ç°æ–­ç‚¹ç»­ä¼ çš„åŠŸèƒ½</p>

:ET