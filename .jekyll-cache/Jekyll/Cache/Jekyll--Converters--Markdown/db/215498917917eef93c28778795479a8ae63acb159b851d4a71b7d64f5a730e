I";<p>在 WPF 中很多小伙伴都会遇到渲染性能的问题，虽然 WPF 的渲染可以甩浏览器渲染几条街，但是还是支持不了游戏级的渲染。在 WPF 使用的 DX 只是优化等级为 9 和 DX 9 差不多的性能，微软在很多开发者的提议开放了现代渲染方法 Composition API 这是 UI 应用的里程碑的技术</p>

<!--more-->

<!-- CreateTime:2019/7/3 10:30:57 -->

<!-- 标签：WPF，渲染,DirectComposition -->

<p>现在这个技术只是最小可用版本，但是还是可以玩一下。</p>

<p>先更新自己的系统到1803或以上，如果是想成为 Windows 开发者，就需要自己的系统是最新的</p>

<p>然后下载安装 VS 2019 最新版本，安装 .NET Core 3.0 预览版</p>

<p>官方下载链接 <a href="https://visualstudio.microsoft.com/zh-hans/downloads/">VisualStudio 2019</a> <a href="https://dotnet.microsoft.com/download/dotnet-core/3.0">.NET Core</a></p>

<h2 id="下载运行代码">下载运行代码</h2>

<p>从 <a href="https://github.com/Microsoft/Windows.UI.Composition-Win32-Samples">github</a> 官方 <a href="https://github.com/Microsoft/Windows.UI.Composition-Win32-Samples">https://github.com/Microsoft/Windows.UI.Composition-Win32-Samples</a> 下载最新代码，尝试编译运行</p>

<p>打开 <code class="language-plaintext highlighter-rouge">dotnet\WPF\HelloComposition</code> 里面的解决方案，注意使用 VisualStudio 2019 打开</p>

<p>通过 Nuget 还原两个库，一个是 <a href="https://www.nuget.org/packages/Microsoft.Windows.SDK.Contracts">Microsoft.Windows.SDK.Contracts</a> 这是一个包含在桌面使用的 Windows Runtime API 库和<a href="https://www.nuget.org/packages/System.Numerics.Vectors">System.Numerics.Vectors</a> 支持向量计算</p>

<p>这里的 HelloComposition 就是最简单的项目，可以通过这个项目了解使用方法</p>

<p>因为这个项目现在还是预览的，要做好使用命令行编译，在一开始发现了这个项目使用的是以前的 csproj 格式，同时也没法直接在 VisualStudio 2019 里面编译成功，于是我将这个项目格式修改为新的格式，通过命令行还原编译之后就可以在 VisualStudio 2019 调试了。</p>

<p>修改方法是使用下面代码替换 HelloComposition.csproj 文件，同时删除 <code class="language-plaintext highlighter-rouge">HelloComposition\Properties\AssemblyInfo.cs</code> 文件</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="p">&lt;</span><span class="n">Project</span> <span class="n">Sdk</span><span class="p">=</span><span class="s">"Microsoft.NET.Sdk.WindowsDesktop"</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="n">PropertyGroup</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">OutputType</span><span class="p">&gt;</span><span class="n">WinExe</span><span class="p">&lt;/</span><span class="n">OutputType</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">TargetFramework</span><span class="p">&gt;</span><span class="n">netcoreapp3</span><span class="p">.</span><span class="m">0</span><span class="p">&lt;/</span><span class="n">TargetFramework</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">UseWPF</span><span class="p">&gt;</span><span class="k">true</span><span class="p">&lt;/</span><span class="n">UseWPF</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="n">PropertyGroup</span><span class="p">&gt;</span>
  <span class="p">&lt;</span><span class="n">ItemGroup</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">PackageReference</span> <span class="n">Include</span><span class="p">=</span><span class="s">"Microsoft.Windows.SDK.Contracts"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="n">Version</span><span class="p">&gt;</span><span class="m">10.0</span><span class="p">.</span><span class="m">17763.144</span><span class="p">-</span><span class="n">preview</span><span class="p">&lt;/</span><span class="n">Version</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="n">PackageReference</span><span class="p">&gt;</span>
    <span class="p">&lt;</span><span class="n">PackageReference</span> <span class="n">Include</span><span class="p">=</span><span class="s">"System.Numerics.Vectors"</span><span class="p">&gt;</span>
      <span class="p">&lt;</span><span class="n">Version</span><span class="p">&gt;</span><span class="m">4.5</span><span class="p">.</span><span class="m">0</span><span class="p">&lt;/</span><span class="n">Version</span><span class="p">&gt;</span>
    <span class="p">&lt;/</span><span class="n">PackageReference</span><span class="p">&gt;</span>
  <span class="p">&lt;/</span><span class="n">ItemGroup</span><span class="p">&gt;</span>
<span class="p">&lt;/</span><span class="n">Project</span><span class="p">&gt;</span>
</code></pre></div></div>

<p>如果不想自己修改 csproj 文件可以<a href="https://github.com/lindexi/lindexi_gd/tree/a8d0df42142b4979807be154ba538b648dd27175/HelloComposition">下载</a>我的修改的版本，先通过命令行还原编译</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="c1">// 先进入 HelloComposition.sln 所在的文件夹</span>
<span class="n">dotnet</span> <span class="n">restore</span> 
<span class="c1">// 还原可能失败，如果发现还原失败可以使用 [我收集的各种公有 NuGet 源](https://blog.walterlv.com/post/public-nuget-sources.html )</span>
<span class="n">dotnet</span> <span class="n">build</span>
</code></pre></div></div>

<p>如果编译成功，那么就可以在 VisualStudio 2019 点击运行调试。如果编译失败，欢迎加入<a href="https://t.me/dotnet_campus">dotnet 职业技术学院</a>交流</p>

<p>运行可以看到下面图片</p>

<!-- ![](image/WPF 使用 Composition API 做高性能渲染/WPF 使用 Composition API 做高性能渲染0.gif) -->

<p><img src="http://image.acmx.xyz/lindexi%2F2019328102935615" alt="" /></p>

<h2 id="项目主要代码">项目主要代码</h2>

<p>那么代码是如何写的？</p>

<p>可以看到主要的代码是 CompositionHostControl 这是一个很普通的 UserControl 控件，在这个控件的 Load 的时候，将自己的内容，也就是一个叫 CompositionHostElement 的 Border 的内容修改为 CompositionHost 的方法</p>

<p>这里的 CompositionHost 是一个自定义的 HwndHost 方法，通过 HwndHost 可以指定为 Host 一个句柄，通过这个方法让 WPF 使用两个不同的渲染方法。</p>

<p>在 CompositionHost 创建了一个新的窗口，然后将这个窗口使用 HwndHost 显示在 WPF 窗口之上，也就是使用 CompositionHost 的控件将会显示在其他任何 WPF 控件的上面，也就是在 CompositionHost 控件的 Bounds 范围内，是不能使用其他的 WPF 控件的。这和在 WPF 中使用其他渲染方法的窗口一样，这个技术也是在 WPF 中使用 WinForms 或 UWP 控件的技术</p>

<p>在 CompositionHost 的主要代码是 InitComposition 方法，在这里创建了 Composition 通过黑科技的方法，感觉这里的代码将会写在一个框架里面，同时也不是很清真，更大的原因是我也不了解这个黑科技是什么，所以就跳过了。</p>

<p>在跳过这个类，其他的代码是非常容易的，可以看到方法的接口和 UWP 的一样，在 <code class="language-plaintext highlighter-rouge">CompositionHostControl_Loaded</code> 方法返回了 Compositor 的字段，对他的使用就和 UWP 的使用一样</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>        <span class="k">private</span> <span class="k">void</span> <span class="nf">CompositionHostControl_Loaded</span><span class="p">(</span><span class="kt">object</span> <span class="n">sender</span><span class="p">,</span> <span class="n">RoutedEventArgs</span> <span class="n">e</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">// If the user changes the DPI scale setting for the screen the app is on,</span>
            <span class="c1">// the CompositionHostControl is reloaded. Don't redo this set up if it's</span>
            <span class="c1">// already been done.</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">compositionHost</span> <span class="k">is</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">currentDpi</span> <span class="p">=</span> <span class="n">VisualTreeHelper</span><span class="p">.</span><span class="nf">GetDpi</span><span class="p">(</span><span class="k">this</span><span class="p">);</span>

                <span class="n">compositionHost</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">CompositionHost</span><span class="p">(</span><span class="n">CompositionHostElement</span><span class="p">.</span><span class="n">ActualHeight</span><span class="p">,</span> <span class="n">CompositionHostElement</span><span class="p">.</span><span class="n">ActualWidth</span><span class="p">);</span>
                <span class="c1">// 手动高亮，下面的代码就是将 CompositionHostElement 这个 Border 的内容修改为 CompositionHost 这个 HwndHost 通过 Host 一个窗口的方法</span>
                <span class="n">CompositionHostElement</span><span class="p">.</span><span class="n">Child</span> <span class="p">=</span> <span class="n">compositionHost</span><span class="p">;</span>

                <span class="c1">// 手动高亮，下面的代码返回 Compositor 字段</span>
                <span class="n">compositor</span> <span class="p">=</span> <span class="n">compositionHost</span><span class="p">.</span><span class="n">Compositor</span><span class="p">;</span>
                <span class="c1">// 手动高亮，下面的代码返回 ContainerVisual 字段</span>
                <span class="n">containerVisual</span> <span class="p">=</span> <span class="n">compositor</span><span class="p">.</span><span class="nf">CreateContainerVisual</span><span class="p">();</span>
                <span class="n">compositionHost</span><span class="p">.</span><span class="n">Child</span> <span class="p">=</span> <span class="n">containerVisual</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>
</code></pre></div></div>

<p>在点击按钮的时候就创建一个 SpriteVisual 加入到 ContainerVisual 里面，然后做 Vector3KeyFrameAnimation 动画</p>

<p>这里面的代码接口和 UWP 相同，就不详细告诉大家如何使用</p>

<h2 id="用到的黑科技">用到的黑科技</h2>

<h3 id="通过-hwndhost-方法拿到一个窗口的句柄">通过 HwndHost 方法拿到一个窗口的句柄</h3>

<p>其实不是直接在 WPF 使用 Composition 而是在创建一个窗口使用 Composition 因为 WPF 的渲染和 Composition 的不相同</p>

<p>也是因为使用了这个技术，所以会存在一些坑，将会在本文下面告诉大家</p>

<h3 id="通过-com-等方法调用额外的系统相关的接口">通过 COM 等方法调用额外的系统相关的接口</h3>

<p>如果只是创建一个空白的窗口是没法直接用到 Composition API 需要使用一些黑科技，这些代码都在 <code class="language-plaintext highlighter-rouge">CompositionHost</code> 因为我也看不懂，所以就跳过</p>

<p>如果想不开请看 <a href="https://docs.microsoft.com/en-us/windows/uwp/composition/using-the-visual-layer-with-wpf#create-a-usercontrol-to-add-your-content-to-the-wpf-visual-tree">Using the Visual Layer with WPF</a></p>

<h3 id="将-visual-layer-的内容封装在-wpf-的用户控件">将 Visual Layer 的内容封装在 WPF 的用户控件</h3>

<p>在 CompositionHostControl 这个用户控件，使用的封装的 Visual Layer 在里面的代码和 UWP 的相同</p>

<p>如何使用可以看 UWP 的 <a href="https://docs.microsoft.com/windows/uwp/composition/visual-layer">Visual Layer documentation</a></p>

<h2 id="预览代码">预览代码</h2>

<p>主要用到类有三个</p>

<h3 id="compositionhost">CompositionHost</h3>

<p>连接 WPF 的渲染和 UWP 的 Visual Layer 也是这个呆魔的主要代码</p>

<p>官方建议是直接复制这个类里面的代码，在 <a href="https://docs.microsoft.com/windows/uwp/composition/using-the-visual-layer-with-wpf#create-an-hwndhost-derived-class-to-host-composition-elements">Create an HwndHost derived class to host composition elements</a> 也只是告诉大家如何写</p>

<h3 id="compositionhostcontrol">CompositionHostControl</h3>

<p>使用封装之后的方法，简单告诉大家如何添加 Visual 和动画</p>

<p>最后一个文件是主窗口，里面也就是放了一个按钮和 CompositionHostControl 代码很简单</p>

<h2 id="不足">不足</h2>

<p>虽然可以在 WPF 用 Composition API 做出好看界面，但是因为主要技术是通过 HwndHost 方法，这个方法也还没有正式使用，存在下面的不足</p>

<ul>
  <li>
    <p>特效依赖于 Win2d 但是现在 win2d 还没有支持桌面的 Nuget 库，需要编译<a href="https://github.com/Microsoft/Win2D">源代码</a> 不过很快就可以直接通过 Nuget 的方法</p>
  </li>
  <li>
    <p>如果需要交互命中测试需要在代码计算 Visual Layer 的 Bounds 没有和在 UWP 通过 xaml 的方法简单绑定对应的命中测试，不过很快也就有封装的方法</p>
  </li>
  <li>
    <p>现在的 Visual Layer 还没有支持渲染文本，但是可以通过 SharpDX 的方法渲染，很快就可以原生支持</p>
  </li>
  <li>
    <p>因为是 Host 的技术，不能自动在 DPI 修改的时候缩放，需要写很多代码适配</p>
  </li>
  <li>
    <p>如果说上面几个坑都还是可以解决的，那么下面的坑就是原理的问题。因为使用了 HwndHost 用了两个渲染方法，在使用 UWP 渲染方法的范围会在窗口的最上也就是 WPF 无法在这个范围放任何的像素，同时也存在焦点等问题</p>
  </li>
</ul>

<p><a href="https://docs.microsoft.com/en-us/windows/uwp/composition/using-the-visual-layer-with-wpf#create-a-usercontrol-to-add-your-content-to-the-wpf-visual-tree">Using the Visual Layer with WPF</a></p>

<p><a href="https://docs.microsoft.com/windows/uwp/composition/visual-layer">Visual Layer documentation</a></p>

<p><a href="https://docs.microsoft.com/en-us/uwp/api/windows.ui.composition">Windows.UI.Composition Namespace</a></p>

<p><a href="https://blog.walterlv.com/post/public-nuget-sources.html">我收集的各种公有 NuGet 源</a></p>

<p><a href="https://github.com/lindexi/lindexi_gd/tree/a8d0df42142b4979807be154ba538b648dd27175/HelloComposition">我修改的代码</a></p>

<p><a href="https://github.com/Microsoft/Windows.UI.Composition-Win32-Samples">官方代码</a></p>

<p>特别感谢</p>

<ul>
  <li><a href="https://www.cnblogs.com/blue-fire">蓝火火</a> 告诉我通过 COM 方法不是通过 PInvoke 调用系统</li>
</ul>

:ET