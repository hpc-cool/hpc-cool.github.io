I"î<p>æˆ‘å°è¯•æ‰¾åˆ°ä¸€ä¸ª B æ ‘çš„å®ç°ï¼Œå°½ç®¡è¿™ä¸ªä¸œè¥¿ååˆ†ç®€å•ï¼Œä½†æ˜¯ä¾ç„¶ç½‘ä¸Šæœ‰å¾ˆå¤šä¸åŒçš„ç‰ˆæœ¬ã€‚æˆ‘åœ¨ justcoding121 çš„ç‰ˆæœ¬ä¸Šé­”æ”¹äº†ä¸€ä¸‹ï¼Œå°±æ˜¯æœ¬æ–‡å¯ä»¥ç”¨æ¥ç»™å¤§å®¶çš„ç‰ˆæœ¬</p>

<!--more-->

<!-- CreateTime:6/9/2020 8:33:56 AM -->

<p>åŸºæœ¬ä¸Šå¾ˆéš¾æœ‰å•¥éœ€æ±‚éœ€è¦ç”¨åˆ° B æ ‘ï¼Œåœ¨ dotnet é‡Œé¢æä¾›äº†é»˜è®¤çš„ SortedList å¯ä»¥è§£å†³å¿«é€Ÿæœå¯»çš„é—®é¢˜ï¼Œåœ¨ SortedList çš„å®ç°åŸç†æ˜¯ä¸€ä¸ªæœå¯»äºŒå‰æ ‘ã€‚å½“ç„¶æœ¬æ–‡ä¸æ˜¯æ¥å¹ SortedList çš„å®ç°äº†ï¼Œç»§ç»­å›åˆ° B æ ‘çš„å®ç°</p>

<p>å› ä¸ºè¿™ä¸ª B æ ‘ä¹Ÿè®¸åªæœ‰åœ¨æ•™ç§‘ä¹¦ä¸Šé¢æ‰æœ‰ç”¨ï¼Œå› æ­¤æ¯”è¾ƒéš¾ä¼šç”¨åˆ°çœŸå®çš„éœ€æ±‚ä¸Šï¼Œå› æ­¤å¤§éƒ¨åˆ†å¯¹ä»–çš„å®ç°ä¹Ÿä»…ä»…æ˜¯èƒ½å®ç°å‡ºæ¥ã€‚åŒ…æ‹¬ <a href="https://github.com/justcoding121/Advanced-Algorithms">https://github.com/justcoding121/Advanced-Algorithms</a> è¿™ä¸ªæ¯”è¾ƒæœ‰åçš„é¡¹ç›®</p>

<p>æœ¬æ–‡æ˜¯ä» <a href="https://github.com/justcoding121/Advanced-Algorithms">https://github.com/justcoding121/Advanced-Algorithms</a> é­”æ”¹çš„ï¼Œæœ€å¤§çš„æ›´æ”¹æ˜¯ä¿®å¤å‘½åé”™è¯¯é—®é¢˜ï¼Œä»¥åŠå¯¼å…¥äº† IValueComparer æ¥å£ï¼Œå¼€æ”¾äº† Find æ–¹æ³•</p>

<p>ä»¥ä¸‹æ˜¯ä½¿ç”¨æ–¹æ³•ï¼Œä½¿ç”¨æ–¹æ³•åŒ…å«æµ‹è¯•æ€§èƒ½å’Œå¯¹æ¯”</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="k">internal</span> <span class="k">class</span> <span class="nc">Program</span>
    <span class="p">{</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">Main</span><span class="p">(</span><span class="kt">string</span><span class="p">[]</span> <span class="n">args</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">random</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Random</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">stopwatch</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">Stopwatch</span><span class="p">();</span>
            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Start</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">nairqearjojaJemjaremkes</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTree</span><span class="p">&lt;</span><span class="n">NairqearjojaJemjaremke</span><span class="p">&gt;();</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">nairqearjojaJemjaremkes</span><span class="p">.</span><span class="nf">Insert</span><span class="p">(</span><span class="k">new</span> <span class="n">NairqearjojaJemjaremke</span>
                <span class="p">{</span>
                    <span class="n">WaleawhalharWogerjedearwhel</span> <span class="p">=</span> <span class="n">random</span><span class="p">.</span><span class="nf">Next</span><span class="p">()</span>
                <span class="p">});</span>
            <span class="p">}</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedTicks</span><span class="p">);</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>

            <span class="kt">var</span> <span class="n">find</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">f</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nairqearjojaJemjaremkes</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">n</span> <span class="p">=&gt;</span>
                    <span class="n">f</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">n</span><span class="p">.</span><span class="n">WaleawhalharWogerjedearwhel</span><span class="p">))</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">find</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Find </span><span class="p">{</span><span class="n">find</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>

            <span class="n">find</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nairqearjojaJemjaremkes</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="k">new</span> <span class="n">NairqearjojaJemjaremke</span>
                <span class="p">{</span>
                    <span class="n">WaleawhalharWogerjedearwhel</span> <span class="p">=</span> <span class="n">i</span>
                <span class="p">})</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">find</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Find </span><span class="p">{</span><span class="n">find</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>

            <span class="n">find</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">nairqearjojaJemjaremkeComparer</span> <span class="p">=</span> <span class="k">new</span> <span class="nf">NairqearjojaJemjaremkeComparer</span><span class="p">();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">1000000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">nairqearjojaJemjaremkeComparer</span><span class="p">.</span><span class="n">NairqearjojaJemjaremke</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">nairqearjojaJemjaremkes</span><span class="p">.</span><span class="nf">Find</span><span class="p">(</span><span class="n">nairqearjojaJemjaremkeComparer</span><span class="p">)</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">find</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Find </span><span class="p">{</span><span class="n">find</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>
            <span class="kt">var</span> <span class="n">list</span> <span class="p">=</span> <span class="k">new</span> <span class="n">SortedList</span><span class="p">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="n">NairqearjojaJemjaremke</span><span class="p">&gt;();</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="kt">var</span> <span class="n">nairqearjojaJemjaremke</span> <span class="p">=</span> <span class="k">new</span> <span class="n">NairqearjojaJemjaremke</span>
                <span class="p">{</span>
                    <span class="n">WaleawhalharWogerjedearwhel</span> <span class="p">=</span> <span class="n">i</span>
                <span class="p">};</span>
                <span class="n">list</span><span class="p">.</span><span class="nf">Add</span><span class="p">(</span><span class="n">nairqearjojaJemjaremke</span><span class="p">.</span><span class="n">WaleawhalharWogerjedearwhel</span><span class="p">,</span><span class="n">nairqearjojaJemjaremke</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Restart</span><span class="p">();</span>

            <span class="n">find</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="m">100000</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">list</span><span class="p">.</span><span class="nf">TryGetValue</span><span class="p">(</span><span class="n">i</span><span class="p">,</span><span class="k">out</span> <span class="n">_</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">find</span><span class="p">++;</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="n">stopwatch</span><span class="p">.</span><span class="nf">Stop</span><span class="p">();</span>

            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="n">stopwatch</span><span class="p">.</span><span class="n">ElapsedMilliseconds</span><span class="p">);</span>
            <span class="n">Console</span><span class="p">.</span><span class="nf">WriteLine</span><span class="p">(</span><span class="s">$"Find </span><span class="p">{</span><span class="n">find</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">class</span> <span class="nc">NairqearjojaJemjaremkeComparer</span> <span class="p">:</span> <span class="n">IValueComparer</span><span class="p">&lt;</span><span class="n">NairqearjojaJemjaremke</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="n">NairqearjojaJemjaremke</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

            <span class="c1">/// &lt;inheritdoc /&gt;</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">NairqearjojaJemjaremke</span> <span class="k">value</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">NairqearjojaJemjaremke</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="n">WaleawhalharWogerjedearwhel</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">class</span> <span class="nc">NairqearjojaJemjaremke</span> <span class="p">:</span> <span class="n">IComparable</span><span class="p">&lt;</span><span class="n">NairqearjojaJemjaremke</span><span class="p">&gt;,</span> <span class="n">IComparable</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="n">WaleawhalharWogerjedearwhel</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

            <span class="c1">/// &lt;inheritdoc /&gt;</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="kt">object</span><span class="p">?</span> <span class="n">obj</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nf">CompareTo</span><span class="p">((</span><span class="n">NairqearjojaJemjaremke</span><span class="p">)</span><span class="n">obj</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">/// &lt;inheritdoc /&gt;</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">NairqearjojaJemjaremke</span> <span class="n">other</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span> <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
                <span class="k">if</span> <span class="p">(</span><span class="nf">ReferenceEquals</span><span class="p">(</span><span class="k">null</span><span class="p">,</span> <span class="n">other</span><span class="p">))</span> <span class="k">return</span> <span class="m">1</span><span class="p">;</span>
                <span class="k">return</span> <span class="n">WaleawhalharWogerjedearwhel</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">other</span><span class="p">.</span><span class="n">WaleawhalharWogerjedearwhel</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>
</code></pre></div></div>

<p>ä¸‹é¢æ˜¯ B æ ‘çš„å®ç°ï¼Œå¤§æ¦‚å¯ä»¥ç›´æ¥å¤åˆ¶ç²˜è´´åˆ°ä½ çš„é¡¹ç›®é‡Œé¢</p>

<p>ä¸‹é¢ä»£ç æ”¾åœ¨ <a href="https://github.com/lindexi/lindexi_gd/tree/6eb1350509a439f6c227b93834b480293408e06a/JerecarwirakalHallnanemne">github</a> æ¬¢è¿å°ä¼™ä¼´è®¿é—®</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code>    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// å€¼æ¯”è¾ƒæ–¹æ³•</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// &lt;typeparam name="T"&gt;&lt;/typeparam&gt;</span>
    <span class="k">public</span> <span class="k">interface</span> <span class="nc">IValueComparer</span><span class="p">&lt;</span><span class="k">in</span> <span class="n">T</span><span class="p">&gt;</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// ä¼ å…¥çš„ &lt;paramref name="t"/&gt; å°±æ˜¯å­˜æ”¾åœ¨æ ‘é‡Œé¢çš„æ•°æ®</span>
        <span class="c1">/// &lt;para&gt;&lt;/para&gt;</span>
        <span class="c1">/// é‡‡ç”¨ &lt;code&gt;x.CompareTo(&lt;paramref name="t"/&gt;)&lt;/code&gt; çš„æ–¹æ³•ï¼Œæ³¨æ„åˆ¤æ–­é¡ºåºä¸èƒ½ç›¸å</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// &lt;param name="t"&gt;&lt;/param&gt;</span>
        <span class="c1">/// &lt;returns&gt;å¦‚æœå­˜æ ¹ x æ¯” &lt;paramref name="t"/&gt; å¤§ï¼Œè¿”å› 1 ç­‰äºè¿”å› 0 çš„å€¼&lt;/returns&gt;</span>
        <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// A B-tree implementation.</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="c1">/// https://github.com/justcoding121/Advanced-Algorithms</span>
    <span class="k">public</span> <span class="k">class</span> <span class="nc">BTree</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerable</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IComparable</span>
    <span class="p">{</span>
        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// åˆ›å»º Bæ ‘</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="c1">/// &lt;param name="maxKeysPerNode"&gt;é»˜è®¤ä¸€ä¸ª Node æœ‰å¤šå°‘ä¸ªæ•°æ®ï¼Œé»˜è®¤å€¼æ˜¯ 3 ä¸ªï¼Œæ³¨æ„ä¸èƒ½ä¼ å…¥å°äº3ä¸ª&lt;/param&gt;</span>
        <span class="k">public</span> <span class="nf">BTree</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxKeysPerNode</span> <span class="p">=</span> <span class="m">3</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">maxKeysPerNode</span> <span class="p">&lt;</span> <span class="m">3</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">ArgumentException</span><span class="p">(</span>
                    <span class="s">$"Max keys per node should be atleast 3. Current value is </span><span class="p">{</span><span class="n">maxKeysPerNode</span><span class="p">}</span><span class="s">"</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="n">_maxKeysPerNode</span> <span class="p">=</span> <span class="n">maxKeysPerNode</span><span class="p">;</span>
            <span class="n">_minKeysPerNode</span> <span class="p">=</span> <span class="n">maxKeysPerNode</span> <span class="p">/</span> <span class="m">2</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// æ€»å…±æœ‰å¤šå°‘æ•°æ®</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="kt">int</span> <span class="n">Count</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">private</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Time complexity: O(log(n)).</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">Max</span>
        <span class="p">{</span>
            <span class="k">get</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Root</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="k">default</span><span class="p">;</span>

                <span class="kt">var</span> <span class="n">maxNode</span> <span class="p">=</span> <span class="nf">FindMaxNode</span><span class="p">(</span><span class="n">Root</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">maxNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">maxNode</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Time complexity: O(log(n)).</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="n">T</span> <span class="n">Min</span>
        <span class="p">{</span>
            <span class="k">get</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">Root</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span> <span class="k">return</span> <span class="k">default</span><span class="p">;</span>

                <span class="kt">var</span> <span class="n">minNode</span> <span class="p">=</span> <span class="nf">FindMinNode</span><span class="p">(</span><span class="n">Root</span><span class="p">);</span>
                <span class="k">return</span> <span class="n">minNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="nf">Find</span><span class="p">(</span><span class="n">IValueComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">comparer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Find</span><span class="p">(</span><span class="n">Root</span><span class="p">,</span> <span class="n">comparer</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="nf">Find</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Find</span><span class="p">(</span><span class="n">Root</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">T</span> <span class="nf">Find</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">comparer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Find</span><span class="p">(</span><span class="n">Root</span><span class="p">,</span> <span class="k">new</span> <span class="nf">DelegateComparer</span><span class="p">(</span><span class="n">comparer</span><span class="p">));</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Time complexity: O(log(n)).</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Insert</span><span class="p">(</span><span class="n">T</span> <span class="n">newValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Root</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Root</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">_maxKeysPerNode</span><span class="p">,</span> <span class="k">null</span><span class="p">)</span> <span class="p">{</span> <span class="n">Keys</span> <span class="p">=</span> <span class="p">{</span> <span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">=</span> <span class="n">newValue</span> <span class="p">}</span> <span class="p">};</span>
                <span class="n">Root</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>
                <span class="n">Count</span><span class="p">++;</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">leafToInsert</span> <span class="p">=</span> <span class="nf">FindInsertionLeaf</span><span class="p">(</span><span class="n">Root</span><span class="p">,</span> <span class="n">newValue</span><span class="p">);</span>
            <span class="nf">InsertAndSplit</span><span class="p">(</span><span class="k">ref</span> <span class="n">leafToInsert</span><span class="p">,</span> <span class="n">newValue</span><span class="p">,</span> <span class="k">null</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
            <span class="n">Count</span><span class="p">++;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Time complexity: O(log(n)).</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">public</span> <span class="k">void</span> <span class="nf">Delete</span><span class="p">(</span><span class="n">T</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">node</span> <span class="p">=</span> <span class="nf">FindDeletionNode</span><span class="p">(</span><span class="n">Root</span><span class="p">,</span> <span class="k">value</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">throw</span> <span class="k">new</span> <span class="nf">Exception</span><span class="p">(</span><span class="s">"Item do not exist in this tree."</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">!=</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">//if node is leaf and no underflow</span>
                <span class="c1">//then just remove the node</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">IsLeaf</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nf">RemoveAt</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">--;</span>

                    <span class="nf">Balance</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="c1">//replace with max node of left tree</span>
                    <span class="kt">var</span> <span class="n">maxNode</span> <span class="p">=</span> <span class="nf">FindMaxNode</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">=</span> <span class="n">maxNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">maxNode</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>

                    <span class="nf">RemoveAt</span><span class="p">(</span><span class="n">maxNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="n">maxNode</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
                    <span class="n">maxNode</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">--;</span>

                    <span class="nf">Balance</span><span class="p">(</span><span class="n">maxNode</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="n">Count</span><span class="p">--;</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="n">IEnumerator</span> <span class="n">IEnumerable</span><span class="p">.</span><span class="nf">GetEnumerator</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">GetEnumerator</span><span class="p">();</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetEnumerator</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="k">new</span> <span class="n">BTreeEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">Root</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_maxKeysPerNode</span><span class="p">;</span>
        <span class="k">private</span> <span class="k">readonly</span> <span class="kt">int</span> <span class="n">_minKeysPerNode</span><span class="p">;</span>

        <span class="k">private</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Root</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="n">T</span> <span class="nf">Find</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">,</span> <span class="n">IValueComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">comparer</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if leaf then its time to insert</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">IsLeaf</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="kt">var</span> <span class="k">value</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">comparer</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="k">value</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="c1">//if not leaf then drill down to leaf</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="kt">var</span> <span class="k">value</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">comparer</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="k">value</span><span class="p">)</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="k">value</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="c1">//current value is less than new value</span>
                    <span class="c1">//drill down to left child of current value</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">comparer</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="k">value</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Find</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">comparer</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="c1">//current value is grearer than new value</span>
                    <span class="c1">//and current value is last element </span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">Find</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">],</span> <span class="n">comparer</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">default</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Find the value node under given node.</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">T</span> <span class="nf">Find</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">,</span> <span class="n">T</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="nf">Find</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="k">new</span> <span class="nf">DefaultComparer</span><span class="p">(</span><span class="k">value</span><span class="p">));</span>
        <span class="p">}</span>


        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Find the leaf node to start initial insertion</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">FindInsertionLeaf</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">,</span> <span class="n">T</span> <span class="n">newValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if leaf then its time to insert</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">IsLeaf</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//if not leaf then drill down to leaf</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="c1">//current value is less than new value</span>
                <span class="c1">//drill down to left child of current value</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newValue</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">FindInsertionLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">newValue</span><span class="p">);</span>
                <span class="p">}</span>
                <span class="c1">//current value is grearer than new value</span>
                <span class="c1">//and current value is last element </span>

                <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">return</span> <span class="nf">FindInsertionLeaf</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">],</span> <span class="n">newValue</span><span class="p">);</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Insert and split recursively up until no split is required</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">void</span> <span class="nf">InsertAndSplit</span><span class="p">(</span><span class="k">ref</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">,</span> <span class="n">T</span> <span class="n">newValue</span><span class="p">,</span>
            <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">newValueLeft</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">newValueRight</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//add new item to current node</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">node</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">_maxKeysPerNode</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
                <span class="n">Root</span> <span class="p">=</span> <span class="n">node</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//newValue have room to fit in this node</span>
            <span class="c1">//so just insert in right spot in asc order of keys</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">!=</span> <span class="n">_maxKeysPerNode</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">InsertToNotFullNode</span><span class="p">(</span><span class="k">ref</span> <span class="n">node</span><span class="p">,</span> <span class="n">newValue</span><span class="p">,</span> <span class="n">newValueLeft</span><span class="p">,</span> <span class="n">newValueRight</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//if node is full then split node</span>
            <span class="c1">//and  then insert new median to parent.</span>

            <span class="c1">//divide the current node values + new Node as left and right sub nodes</span>
            <span class="kt">var</span> <span class="n">left</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">_maxKeysPerNode</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">right</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">_maxKeysPerNode</span><span class="p">,</span> <span class="k">null</span><span class="p">);</span>

            <span class="c1">//median of current Node</span>
            <span class="kt">var</span> <span class="n">currentMedianIndex</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="nf">GetMedianIndex</span><span class="p">();</span>

            <span class="c1">//init currentNode under consideration to left</span>
            <span class="kt">var</span> <span class="n">currentNode</span> <span class="p">=</span> <span class="n">left</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">currentNodeIndex</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

            <span class="c1">//new Median also takes new Value in to Account</span>
            <span class="kt">var</span> <span class="n">newMedian</span> <span class="p">=</span> <span class="k">default</span><span class="p">(</span><span class="n">T</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">newMedianSet</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>
            <span class="kt">var</span> <span class="n">newValueInserted</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="c1">//keep track of each insertion</span>
            <span class="kt">var</span> <span class="n">insertionCount</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

            <span class="c1">//insert newValue and existing values in sorted order</span>
            <span class="c1">//to left and right nodes</span>
            <span class="c1">//set new median during sorting</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="c1">//if insertion count reached new median</span>
                <span class="c1">//set the new median by picking the next smallest value</span>
                <span class="k">if</span> <span class="p">(!</span><span class="n">newMedianSet</span> <span class="p">&amp;&amp;</span> <span class="n">insertionCount</span> <span class="p">==</span> <span class="n">currentMedianIndex</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">newMedianSet</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

                    <span class="c1">//median can be the new value or node.keys[i] (next node key)</span>
                    <span class="c1">//whichever is smaller</span>
                    <span class="k">if</span> <span class="p">(!</span><span class="n">newValueInserted</span> <span class="p">&amp;&amp;</span> <span class="n">newValue</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="c1">//median is new value</span>
                        <span class="n">newMedian</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">;</span>
                        <span class="n">newValueInserted</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">newValueLeft</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNode</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">,</span> <span class="n">newValueLeft</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="c1">//now fill right node</span>
                        <span class="n">currentNode</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
                        <span class="n">currentNodeIndex</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

                        <span class="k">if</span> <span class="p">(</span><span class="n">newValueRight</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                        <span class="p">{</span>
                            <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">newValueRight</span><span class="p">);</span>
                        <span class="p">}</span>

                        <span class="n">i</span><span class="p">--;</span>
                        <span class="n">insertionCount</span><span class="p">++;</span>
                        <span class="k">continue</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="c1">//median is next node</span>
                    <span class="n">newMedian</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                    <span class="c1">//now fill right node</span>
                    <span class="n">currentNode</span> <span class="p">=</span> <span class="n">right</span><span class="p">;</span>
                    <span class="n">currentNodeIndex</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="c1">//pick the smaller among newValue and node.Keys[i]</span>
                <span class="c1">//and insert in to currentNode (left and right nodes)</span>
                <span class="c1">//if new Value was already inserted then just copy from node.Keys in sequence</span>
                <span class="c1">//since node.Keys is already in sorted order it should be fine</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newValueInserted</span> <span class="p">||</span> <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">newValue</span><span class="p">)</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">currentNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">currentNodeIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
                    <span class="n">currentNode</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

                    <span class="c1">//if child is set don't set again</span>
                    <span class="c1">//the child was already set by last newValueRight or last node</span>
                    <span class="k">if</span> <span class="p">(</span><span class="n">currentNode</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">currentNodeIndex</span><span class="p">]</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNodeIndex</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                    <span class="p">}</span>

                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNodeIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">]);</span>
                <span class="p">}</span>
                <span class="k">else</span>
                <span class="p">{</span>
                    <span class="n">currentNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">currentNodeIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">;</span>
                    <span class="n">currentNode</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNodeIndex</span><span class="p">,</span> <span class="n">newValueLeft</span><span class="p">);</span>
                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNodeIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">newValueRight</span><span class="p">);</span>

                    <span class="n">i</span><span class="p">--;</span>
                    <span class="n">newValueInserted</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="n">currentNodeIndex</span><span class="p">++;</span>
                <span class="n">insertionCount</span><span class="p">++;</span>
            <span class="p">}</span>

            <span class="c1">//could be that thew newKey is the greatest </span>
            <span class="c1">//so insert at end</span>
            <span class="k">if</span> <span class="p">(!</span><span class="n">newValueInserted</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">currentNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">currentNodeIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">;</span>
                <span class="n">currentNode</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

                <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNodeIndex</span><span class="p">,</span> <span class="n">newValueLeft</span><span class="p">);</span>
                <span class="nf">SetChild</span><span class="p">(</span><span class="n">currentNode</span><span class="p">,</span> <span class="n">currentNodeIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">newValueRight</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="c1">//insert overflow element (newMedian) to parent</span>
            <span class="kt">var</span> <span class="n">parent</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>
            <span class="nf">InsertAndSplit</span><span class="p">(</span><span class="k">ref</span> <span class="n">parent</span><span class="p">,</span> <span class="n">newMedian</span><span class="p">,</span> <span class="n">left</span><span class="p">,</span> <span class="n">right</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Insert to a node that is not full</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">InsertToNotFullNode</span><span class="p">(</span><span class="k">ref</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">,</span> <span class="n">T</span> <span class="n">newValue</span><span class="p">,</span>
            <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">newValueLeft</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">newValueRight</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">inserted</span> <span class="p">=</span> <span class="k">false</span><span class="p">;</span>

            <span class="c1">//insert in sorted order</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">newValue</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">&gt;=</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="k">continue</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="nf">InsertAt</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">newValue</span><span class="p">);</span>
                <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

                <span class="c1">//Insert children if any</span>
                <span class="nf">SetChild</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span><span class="p">,</span> <span class="n">newValueLeft</span><span class="p">);</span>
                <span class="nf">InsertChild</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">newValueRight</span><span class="p">);</span>


                <span class="n">inserted</span> <span class="p">=</span> <span class="k">true</span><span class="p">;</span>
                <span class="k">break</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//newValue is the greatest</span>
            <span class="c1">//element should be inserted at the end then</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">inserted</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">]</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">;</span>
            <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

            <span class="nf">SetChild</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">,</span> <span class="n">newValueLeft</span><span class="p">);</span>
            <span class="nf">SetChild</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">,</span> <span class="n">newValueRight</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// return the node containing max value which will be a leaf at the right most</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">FindMinNode</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if leaf return node</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">IsLeaf</span> <span class="p">?</span> <span class="n">node</span> <span class="p">:</span> <span class="nf">FindMinNode</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// return the node containing max value which will be a leaf at the right most</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">FindMaxNode</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if leaf return node</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">IsLeaf</span> <span class="p">?</span> <span class="n">node</span> <span class="p">:</span> <span class="nf">FindMaxNode</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">]);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Balance a node which is short of Keys by rotations or merge</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">void</span> <span class="nf">Balance</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span> <span class="p">==</span> <span class="n">Root</span> <span class="p">||</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">&gt;=</span> <span class="n">_minKeysPerNode</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">rightSibling</span> <span class="p">=</span> <span class="nf">GetRightSibling</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rightSibling</span> <span class="p">!=</span> <span class="k">null</span>
                <span class="p">&amp;&amp;</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">&gt;</span> <span class="n">_minKeysPerNode</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">LeftRotate</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="kt">var</span> <span class="n">leftSibling</span> <span class="p">=</span> <span class="nf">GetLeftSibling</span><span class="p">(</span><span class="n">node</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">leftSibling</span> <span class="p">!=</span> <span class="k">null</span>
                <span class="p">&amp;&amp;</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">&gt;</span> <span class="n">_minKeysPerNode</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">RightRotate</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">rightSibling</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Sandwich</span><span class="p">(</span><span class="n">node</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">);</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="nf">Sandwich</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">,</span> <span class="n">node</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">///  merge two adjacent siblings to one node</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">void</span> <span class="nf">Sandwich</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">leftSibling</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">rightSibling</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">separatorIndex</span> <span class="p">=</span> <span class="nf">GetNextSeparatorIndex</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">parent</span> <span class="p">=</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>

            <span class="kt">var</span> <span class="n">newNode</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;(</span><span class="n">_maxKeysPerNode</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Parent</span><span class="p">);</span>
            <span class="kt">var</span> <span class="n">newIndex</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">newNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">newIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newIndex</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="n">newIndex</span><span class="p">++;</span>
            <span class="p">}</span>

            <span class="c1">//special case when left sibling is empty </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">SetChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newIndex</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="n">newNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">newIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">parent</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">separatorIndex</span><span class="p">];</span>
            <span class="n">newIndex</span><span class="p">++;</span>

            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="n">newNode</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">newIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newIndex</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="nf">SetChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">]);</span>
                <span class="p">}</span>

                <span class="n">newIndex</span><span class="p">++;</span>
            <span class="p">}</span>

            <span class="c1">//special case when left sibling is empty </span>
            <span class="k">if</span> <span class="p">(</span><span class="n">rightSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="m">0</span> <span class="p">&amp;&amp;</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">SetChild</span><span class="p">(</span><span class="n">newNode</span><span class="p">,</span> <span class="n">newIndex</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>
            <span class="p">}</span>

            <span class="n">newNode</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">=</span> <span class="n">newIndex</span><span class="p">;</span>
            <span class="nf">SetChild</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">separatorIndex</span><span class="p">,</span> <span class="n">newNode</span><span class="p">);</span>
            <span class="nf">RemoveAt</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="n">separatorIndex</span><span class="p">);</span>
            <span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">--;</span>

            <span class="nf">RemoveChild</span><span class="p">(</span><span class="n">parent</span><span class="p">,</span> <span class="n">separatorIndex</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>


            <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="m">0</span>
                <span class="p">&amp;&amp;</span> <span class="n">parent</span> <span class="p">==</span> <span class="n">Root</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">Root</span> <span class="p">=</span> <span class="n">newNode</span><span class="p">;</span>
                <span class="n">Root</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>

                <span class="k">if</span> <span class="p">(</span><span class="n">Root</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">Root</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
                <span class="p">}</span>

                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">&lt;</span> <span class="n">_minKeysPerNode</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="nf">Balance</span><span class="p">(</span><span class="n">parent</span><span class="p">);</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// do a right rotation </span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">RightRotate</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">leftSibling</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">rightSibling</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">parentIndex</span> <span class="p">=</span> <span class="nf">GetNextSeparatorIndex</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">);</span>

            <span class="nf">InsertAt</span><span class="p">(</span><span class="n">rightSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">parentIndex</span><span class="p">]);</span>
            <span class="n">rightSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

            <span class="nf">InsertChild</span><span class="p">(</span><span class="n">rightSibling</span><span class="p">,</span> <span class="m">0</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">]);</span>

            <span class="n">rightSibling</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">parentIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>

            <span class="nf">RemoveAt</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
            <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">--;</span>

            <span class="nf">RemoveChild</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">+</span> <span class="m">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// do a left rotation</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">LeftRotate</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">leftSibling</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">rightSibling</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">parentIndex</span> <span class="p">=</span> <span class="nf">GetNextSeparatorIndex</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">);</span>
            <span class="n">leftSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">]</span> <span class="p">=</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">parentIndex</span><span class="p">];</span>
            <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">++;</span>

            <span class="nf">SetChild</span><span class="p">(</span><span class="n">leftSibling</span><span class="p">,</span> <span class="n">leftSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">,</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]);</span>


            <span class="n">leftSibling</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">parentIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">rightSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="m">0</span><span class="p">];</span>

            <span class="nf">RemoveAt</span><span class="p">(</span><span class="n">rightSibling</span><span class="p">.</span><span class="n">Keys</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
            <span class="n">rightSibling</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">--;</span>

            <span class="nf">RemoveChild</span><span class="p">(</span><span class="n">rightSibling</span><span class="p">,</span> <span class="m">0</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Locate the node in which the item to delete exist</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">FindDeletionNode</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">,</span> <span class="n">T</span> <span class="k">value</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//if leaf then its time to insert</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">IsLeaf</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>
            <span class="k">else</span>
            <span class="p">{</span>
                <span class="c1">//if not leaf then drill down to leaf</span>
                <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;</span> <span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
                <span class="p">{</span>
                    <span class="k">if</span> <span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="n">node</span><span class="p">;</span>
                    <span class="p">}</span>

                    <span class="c1">//current value is less than new value</span>
                    <span class="c1">//drill down to left child of current value</span>
                    <span class="k">if</span> <span class="p">(</span><span class="k">value</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">&lt;</span> <span class="m">0</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">FindDeletionNode</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="k">value</span><span class="p">);</span>
                    <span class="p">}</span>
                    <span class="c1">//current value is grearer than new value</span>
                    <span class="c1">//and current value is last element </span>

                    <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">==</span> <span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">)</span>
                    <span class="p">{</span>
                        <span class="k">return</span> <span class="nf">FindDeletionNode</span><span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span> <span class="p">+</span> <span class="m">1</span><span class="p">],</span> <span class="k">value</span><span class="p">);</span>
                    <span class="p">}</span>
                <span class="p">}</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Get next key separator index after this child Node in parent </span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="kt">int</span> <span class="nf">GetNextSeparatorIndex</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">parent</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">==</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="m">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">==</span> <span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">-</span> <span class="m">1</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">Index</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// get the right sibling node</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetRightSibling</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="kt">var</span> <span class="n">parent</span> <span class="p">=</span> <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">;</span>

            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">==</span> <span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span> <span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// get left sibling node</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetLeftSibling</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">node</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">==</span> <span class="m">0</span> <span class="p">?</span> <span class="k">null</span> <span class="p">:</span> <span class="n">node</span><span class="p">.</span><span class="n">Parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">node</span><span class="p">.</span><span class="n">Index</span> <span class="p">-</span> <span class="m">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">SetChild</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">childIndex</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">child</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">childIndex</span><span class="p">]</span> <span class="p">=</span> <span class="n">child</span><span class="p">;</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="n">child</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
            <span class="n">child</span><span class="p">.</span><span class="n">Index</span> <span class="p">=</span> <span class="n">childIndex</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">InsertChild</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">childIndex</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">child</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">InsertAt</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">,</span> <span class="n">childIndex</span><span class="p">,</span> <span class="n">child</span><span class="p">);</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">child</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">child</span><span class="p">.</span><span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">//update indices</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="n">childIndex</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;=</span> <span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Index</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="nf">RemoveChild</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">parent</span><span class="p">,</span> <span class="kt">int</span> <span class="n">childIndex</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="nf">RemoveAt</span><span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">,</span> <span class="n">childIndex</span><span class="p">);</span>

            <span class="c1">//update indices</span>
            <span class="k">for</span> <span class="p">(</span><span class="kt">var</span> <span class="n">i</span> <span class="p">=</span> <span class="n">childIndex</span><span class="p">;</span> <span class="n">i</span> <span class="p">&lt;=</span> <span class="n">parent</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">;</span> <span class="n">i</span><span class="p">++)</span>
            <span class="p">{</span>
                <span class="k">if</span> <span class="p">(</span><span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="p">!=</span> <span class="k">null</span><span class="p">)</span>
                <span class="p">{</span>
                    <span class="n">parent</span><span class="p">.</span><span class="n">Children</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Index</span> <span class="p">=</span> <span class="n">i</span><span class="p">;</span>
                <span class="p">}</span>
            <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Shift array right at index to make room for new insertion</span>
        <span class="c1">/// And then insert at index</span>
        <span class="c1">/// Assumes array have atleast one empty index at end</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">InsertAt</span><span class="p">&lt;</span><span class="n">TS</span><span class="p">&gt;(</span><span class="n">TS</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">,</span> <span class="n">TS</span> <span class="n">newValue</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//shift elements right by one indice from index</span>
            <span class="n">Array</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">index</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
            <span class="c1">//now set the value</span>
            <span class="n">array</span><span class="p">[</span><span class="n">index</span><span class="p">]</span> <span class="p">=</span> <span class="n">newValue</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Shift array left at index    </span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">private</span> <span class="k">static</span> <span class="k">void</span> <span class="n">RemoveAt</span><span class="p">&lt;</span><span class="n">TS</span><span class="p">&gt;(</span><span class="n">TS</span><span class="p">[]</span> <span class="n">array</span><span class="p">,</span> <span class="kt">int</span> <span class="n">index</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="c1">//shift elements right by one indice from index</span>
            <span class="n">Array</span><span class="p">.</span><span class="nf">Copy</span><span class="p">(</span><span class="n">array</span><span class="p">,</span> <span class="n">index</span> <span class="p">+</span> <span class="m">1</span><span class="p">,</span> <span class="n">array</span><span class="p">,</span> <span class="n">index</span><span class="p">,</span> <span class="n">array</span><span class="p">.</span><span class="n">Length</span> <span class="p">-</span> <span class="n">index</span> <span class="p">-</span> <span class="m">1</span><span class="p">);</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">class</span> <span class="nc">DelegateComparer</span> <span class="p">:</span> <span class="n">IValueComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="nf">DelegateComparer</span><span class="p">(</span><span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">comparer</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_comparer</span> <span class="p">=</span> <span class="n">comparer</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">/// &lt;inheritdoc /&gt;</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="nf">_comparer</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">private</span> <span class="k">readonly</span> <span class="n">Func</span><span class="p">&lt;</span><span class="n">T</span><span class="p">,</span> <span class="kt">int</span><span class="p">&gt;</span> <span class="n">_comparer</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">class</span> <span class="nc">DefaultComparer</span> <span class="p">:</span> <span class="n">IValueComparer</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span>
        <span class="p">{</span>
            <span class="k">public</span> <span class="nf">DefaultComparer</span><span class="p">(</span><span class="n">T</span> <span class="n">compareObject</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">CompareObject</span> <span class="p">=</span> <span class="n">compareObject</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="c1">/// &lt;inheritdoc /&gt;</span>
            <span class="k">public</span> <span class="kt">int</span> <span class="nf">CompareTo</span><span class="p">(</span><span class="n">T</span> <span class="n">t</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="n">CompareObject</span><span class="p">.</span><span class="nf">CompareTo</span><span class="p">(</span><span class="n">t</span><span class="p">);</span>
            <span class="p">}</span>

            <span class="k">private</span> <span class="n">T</span> <span class="n">CompareObject</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">/// &lt;summary&gt;</span>
    <span class="c1">/// abstract node shared by both B and B+ tree nodes</span>
    <span class="c1">/// so that we can use this for common tests across B and B+ tree</span>
    <span class="c1">/// &lt;/summary&gt;</span>
    <span class="k">internal</span> <span class="k">abstract</span> <span class="k">class</span> <span class="nc">BNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IComparable</span>
    <span class="p">{</span>
        <span class="k">internal</span> <span class="nf">BNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxKeysPerNode</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Keys</span> <span class="p">=</span> <span class="k">new</span> <span class="n">T</span><span class="p">[</span><span class="n">maxKeysPerNode</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// Array Index of this node in parent's Children array</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">internal</span> <span class="kt">int</span> <span class="n">Index</span> <span class="p">{</span> <span class="k">set</span><span class="p">;</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">internal</span> <span class="n">T</span><span class="p">[]</span> <span class="n">Keys</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">internal</span> <span class="kt">int</span> <span class="n">KeyCount</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>

        <span class="c1">//for common unit testing across B and B+ tree</span>
        <span class="k">internal</span> <span class="k">abstract</span> <span class="n">BNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetParent</span><span class="p">();</span>
        <span class="k">internal</span> <span class="k">abstract</span> <span class="n">BNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;[]</span> <span class="nf">GetChildren</span><span class="p">();</span>

        <span class="k">internal</span> <span class="kt">int</span> <span class="nf">GetMedianIndex</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="p">(</span><span class="n">KeyCount</span> <span class="p">/</span> <span class="m">2</span><span class="p">)</span> <span class="p">+</span> <span class="m">1</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">internal</span> <span class="k">class</span> <span class="nc">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">BNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IComparable</span>
    <span class="p">{</span>
        <span class="k">internal</span> <span class="nf">BTreeNode</span><span class="p">(</span><span class="kt">int</span> <span class="n">maxKeysPerNode</span><span class="p">,</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">parent</span><span class="p">)</span>
            <span class="p">:</span> <span class="k">base</span><span class="p">(</span><span class="n">maxKeysPerNode</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">Parent</span> <span class="p">=</span> <span class="n">parent</span><span class="p">;</span>
            <span class="n">Children</span> <span class="p">=</span> <span class="k">new</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;[</span><span class="n">maxKeysPerNode</span> <span class="p">+</span> <span class="m">1</span><span class="p">];</span>
        <span class="p">}</span>

        <span class="k">internal</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">Parent</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="k">set</span><span class="p">;</span> <span class="p">}</span>
        <span class="k">internal</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;[]</span> <span class="n">Children</span> <span class="p">{</span> <span class="k">get</span><span class="p">;</span> <span class="p">}</span>

        <span class="k">internal</span> <span class="kt">bool</span> <span class="n">IsLeaf</span> <span class="p">=&gt;</span> <span class="n">Children</span><span class="p">[</span><span class="m">0</span><span class="p">]</span> <span class="p">==</span> <span class="k">null</span><span class="p">;</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// For shared test method accross B and B+ tree</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">internal</span> <span class="k">override</span> <span class="n">BNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="nf">GetParent</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Parent</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="c1">/// &lt;summary&gt;</span>
        <span class="c1">/// For shared test method accross B and B+ tree</span>
        <span class="c1">/// &lt;/summary&gt;</span>
        <span class="k">internal</span> <span class="k">override</span> <span class="n">BNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;[]</span> <span class="nf">GetChildren</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">return</span> <span class="n">Children</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>

    <span class="k">internal</span> <span class="k">class</span> <span class="nc">BTreeEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="p">:</span> <span class="n">IEnumerator</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="k">where</span> <span class="n">T</span> <span class="p">:</span> <span class="n">IComparable</span>
    <span class="p">{</span>
        <span class="k">internal</span> <span class="nf">BTreeEnumerator</span><span class="p">(</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">root</span><span class="p">)</span>
        <span class="p">{</span>
            <span class="n">_root</span> <span class="p">=</span> <span class="n">root</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="kt">bool</span> <span class="nf">MoveNext</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">_root</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">_progress</span> <span class="p">==</span> <span class="k">null</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_current</span> <span class="p">=</span> <span class="n">_root</span><span class="p">;</span>
                <span class="n">_progress</span> <span class="p">=</span> <span class="k">new</span> <span class="n">Stack</span><span class="p">&lt;</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;(</span><span class="n">_root</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="nf">Take</span><span class="p">(</span><span class="n">_root</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">+</span> <span class="m">1</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">!=</span> <span class="k">null</span><span class="p">));</span>
                <span class="k">return</span> <span class="n">_current</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">_current</span> <span class="p">!=</span> <span class="k">null</span> <span class="p">&amp;&amp;</span> <span class="n">_index</span> <span class="p">+</span> <span class="m">1</span> <span class="p">&lt;</span> <span class="n">_current</span><span class="p">.</span><span class="n">KeyCount</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_index</span><span class="p">++;</span>
                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">if</span> <span class="p">(</span><span class="n">_progress</span><span class="p">.</span><span class="n">Count</span> <span class="p">&gt;</span> <span class="m">0</span><span class="p">)</span>
            <span class="p">{</span>
                <span class="n">_index</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>

                <span class="n">_current</span> <span class="p">=</span> <span class="n">_progress</span><span class="p">.</span><span class="nf">Pop</span><span class="p">();</span>

                <span class="k">foreach</span> <span class="p">(</span><span class="kt">var</span> <span class="n">child</span> <span class="k">in</span> <span class="n">_current</span><span class="p">.</span><span class="n">Children</span><span class="p">.</span><span class="nf">Take</span><span class="p">(</span><span class="n">_current</span><span class="p">.</span><span class="n">KeyCount</span> <span class="p">+</span> <span class="m">1</span><span class="p">).</span><span class="nf">Where</span><span class="p">(</span><span class="n">x</span> <span class="p">=&gt;</span> <span class="n">x</span> <span class="p">!=</span> <span class="k">null</span><span class="p">))</span>
                <span class="p">{</span>
                    <span class="n">_progress</span><span class="p">.</span><span class="nf">Push</span><span class="p">(</span><span class="n">child</span><span class="p">);</span>
                <span class="p">}</span>

                <span class="k">return</span> <span class="k">true</span><span class="p">;</span>
            <span class="p">}</span>

            <span class="k">return</span> <span class="k">false</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Reset</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_progress</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="n">_current</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
            <span class="n">_index</span> <span class="p">=</span> <span class="m">0</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="kt">object</span> <span class="n">IEnumerator</span><span class="p">.</span><span class="n">Current</span> <span class="p">=&gt;</span> <span class="n">Current</span><span class="p">;</span>

        <span class="k">public</span> <span class="n">T</span> <span class="n">Current</span> <span class="p">=&gt;</span> <span class="n">_current</span><span class="p">.</span><span class="n">Keys</span><span class="p">[</span><span class="n">_index</span><span class="p">];</span>

        <span class="k">public</span> <span class="k">void</span> <span class="nf">Dispose</span><span class="p">()</span>
        <span class="p">{</span>
            <span class="n">_progress</span> <span class="p">=</span> <span class="k">null</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="k">private</span> <span class="k">readonly</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_root</span><span class="p">;</span>

        <span class="k">private</span> <span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;</span> <span class="n">_current</span><span class="p">;</span>
        <span class="k">private</span> <span class="kt">int</span> <span class="n">_index</span><span class="p">;</span>
        <span class="k">private</span> <span class="n">Stack</span><span class="p">&lt;</span><span class="n">BTreeNode</span><span class="p">&lt;</span><span class="n">T</span><span class="p">&gt;&gt;</span> <span class="n">_progress</span><span class="p">;</span>
    <span class="p">}</span>
</code></pre></div></div>

:ET