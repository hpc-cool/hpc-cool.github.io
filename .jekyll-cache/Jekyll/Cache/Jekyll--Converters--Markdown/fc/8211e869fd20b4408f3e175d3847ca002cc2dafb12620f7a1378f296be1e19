I"Ì%<p>åœ¨ WPF é‡Œé¢æœ‰å…¶ä»–è½¯ä»¶å®Œå…¨æ¯”ä¸ä¸Šçš„è¶…å¿«é€Ÿçš„è§¦æ‘¸ï¼Œè¿™ä¸ªè§¦æ‘¸æ˜¯é€šè¿‡ PenImc è·å–çš„ã€‚ç°åœ¨ WPF å¼€æºäº†ï¼Œæœ¬æ–‡å°±å¸¦å¤§å®¶æ¥é˜…è¯»è§¦æ‘¸åº•å±‚çš„ä»£ç ï¼Œé˜…è¯»æœ¬æ–‡éœ€è¦ä¸€ç‚¹ C# å’Œ C++ åŸºç¡€</p>

<!--more-->

<!-- CreateTime:4/19/2020 5:23:45 PM -->

<p>ç°åœ¨ WPF å¼€æºï¼Œæ‰€æœ‰æºä»£ç éƒ½å¯ä»¥åœ¨å®˜æ–¹ä»£ç æ‰¾åˆ°ï¼Œæœ¬æ–‡åªæ˜¯è®©å¤§å®¶èƒ½å¤Ÿæ›´å¿«çš„äº†è§£æ•´ä¸ªè§¦æ‘¸çš„ä»£ç å’Œæ›´å¿«çš„äº†è§£ä»£ç ï¼Œå’ŒçŸ¥é“å¯¹åº”çš„åŠŸèƒ½åœ¨å“ªä¸ªä»£ç </p>

<p>åœ¨WPFçš„è§¦æ‘¸çš„ PenThreadWorker è°ƒç”¨ ThreadProc çš„æ–¹æ³•ï¼Œå°±é€šè¿‡ MS.Win32.Penimc.UnsafeNativeMethods.GetPenEvent æ–¹æ³•è·å–è§¦æ‘¸ã€‚æœ¬æ–‡ä»…è®¨è®ºåœ¨ PenThreadWorker ä¸‹å±‚çš„å†…å®¹ï¼Œåœ¨æ­¤ä¸Šå±‚çš„å†…å®¹ï¼Œè¯·çœ‹<a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E5%88%B0%E4%BA%8B%E4%BB%B6.html">WPF è§¦æ‘¸åˆ°äº‹ä»¶</a></p>

<p>é‚£ä¹ˆåœ¨ PenImc é‡Œé¢åšäº†ä»€ä¹ˆï¼Ÿ</p>

<p>åœ¨ PenImc åŸç†é‡Œé¢ï¼Œå…¶å®å°±æ˜¯é€šè¿‡å…±äº«å†…å­˜å’Œ COM çš„æ–¹å¼é€šè¿‡ RealTimeStylus çš„æ–¹å¼å¿«é€Ÿè·å–è§¦æ‘¸æ¶ˆæ¯</p>

<p>å…ˆé€šè¿‡ WISPTIS_SM_SECTION_NAME å’Œ WISPTIS_SM_MUTEX_NAME åˆ†åˆ«æ‹¿åˆ°å…±äº«å†…å­˜å’Œè¿›ç¨‹é”è¿™æ ·å¯ä»¥é€šè¿‡é”é€šçŸ¥å…±äº«å†…å­˜æ”¶åˆ°æ¶ˆæ¯ï¼Œç„¶åé€šè¿‡è¯»å–å†…å­˜çš„ä¿¡æ¯è¿”å›åˆ°ä¸Šå±‚</p>

<p>æ•´ä¸ªåˆå§‹åŒ–çš„ä»£ç æ”¾åœ¨ PimcContext.cpp é‡Œ</p>

<p>åœ¨ <code class="language-plaintext highlighter-rouge">HRESULT CPimcContext::InitNamedCommunications(__in CComPtr&lt;ITabletContextP&gt; pCtxP)</code> çš„æ–¹æ³•é‡Œé¢ï¼Œåˆå§‹ szSectionName å­—ç¬¦ä¸²ä½œä¸ºå‘½åç®¡é“è¿æ¥æ–¹æ³•</p>

<pre><code class="language-C++">    TCHAR szSectionName[MAX_PATH + 1];

    StringCchPrintf(
        szSectionName,
        LENGTHOFARRAY(szSectionName),
        WISPTIS_SM_SECTION_NAME,
        dwPid,
        dwFileMappingId);
</code></pre>

<p>è€Œ <code class="language-plaintext highlighter-rouge">WISPTIS_SM_SECTION_NAME</code> çš„å®šä¹‰å¦‚ä¸‹</p>

<pre><code class="language-C++">#define WISPTIS_SM_MORE_DATA_EVENT_NAME     _T("wisptis-1-%d-%u")
#define WISPTIS_SM_MUTEX_NAME               _T("wisptis-2-%d-%u")
#define WISPTIS_SM_SECTION_NAME             _T("wisptis-3-%d-%u")
#define WISPTIS_SM_THREAD_EVENT_NAME        _T("wisptis-4-%u")
</code></pre>

<p>æ­¤æ—¶é€šè¿‡æ‰“å¼€å†…å­˜çš„æ–¹å¼</p>

<pre><code class="language-C++">    m_hFileMappingSharedMemory = OpenFileMapping(FILE_MAP_READ | FILE_MAP_WRITE, FALSE, szSectionName);
</code></pre>

<p>å¯ä»¥è·å–å†…å­˜ä¿¡æ¯</p>

<pre><code class="language-C++">    m_pSharedMemoryHeader = (SHAREDMEMORY_HEADER*)MapViewOfFile(
        m_hFileMappingSharedMemory,     // handle
        FILE_MAP_READ | FILE_MAP_WRITE, // desired access
        0,       // offset in file, High
        0,       // offset in file, Low
        sizeof(SHAREDMEMORY_HEADER));   // number of bytes to map

    m_pbSharedMemoryRawData = (BYTE*)MapViewOfFile(
        m_hFileMappingSharedMemory,     // handle
        FILE_MAP_READ,                  // desired access
        0,       // offset in file, High
        0,       // offset in file, Low
        m_pSharedMemoryHeader-&gt;cbTotal);// number of bytes to map
</code></pre>

<p>å…³äºæ‰“å¼€çš„ä»£ç è¯·çœ‹</p>

<p><a href="https://docs.microsoft.com/en-us/windows/win32/tablet/itabletcontextp-usenamedsharedmemorycommunications">ITabletContextP::UseNamedSharedMemoryCommunications method - Win32 apps</a></p>

<p>æ­¤æ—¶å°±å¯ä»¥é€šè¿‡ <code class="language-plaintext highlighter-rouge">m_pbSharedMemoryRawData</code> è·å–å†…å­˜ä¿¡æ¯</p>

<p>è¿™å°±æ˜¯åˆå§‹åŒ–çš„ä»£ç </p>

<p>åœ¨ WPF è°ƒç”¨ GetPenEvent æ–¹æ³•ï¼Œå°†ä¼šè¿›å…¥ PimcContext.cpp çš„ GetPenEvent æ–¹æ³•</p>

<p>åœ¨è¿™ä¸ªæ–¹æ³•é‡Œé¢å…ˆé€šè¿‡ MsgWaitForMultipleObjectsEx ç­‰å¾… Wisp æœåŠ¡çš„æ”¶é›†ï¼Œåœ¨æ”¶é›†å®Œæˆä¹‹åä¼šé‡Šæ”¾é”ï¼Œè¿›å…¥ GetPenEventCore æ–¹æ³•</p>

<p>åœ¨ GetPenEventCore ä½¿ç”¨å¾ˆé•¿çš„åˆ¤æ–­é€»è¾‘ï¼Œå…¶ä¸­ä¸»è¦æ˜¯åˆ¤æ–­å½“å‰æ˜¯è·å–æ•°æ®æ‰ä¼šè¿›å…¥åˆ° WPF çš„æ”¶é›†åˆ°è§¦æ‘¸ç‚¹</p>

<pre><code class="language-C++"> switch (dwWait)
 {
    case WAIT_TIMEOUT:
        m_fSingleFireTimeout = FALSE; // (only fire the timeout once before more data shows up)
        *pEvt      = 1; // timeout event
        *pCursorId = 0;
        *pcPackets = 0;
        *pcbPacket = 0;
        *pPackets  = NULL;
        break;

    case WAIT_OBJECT_0 + 0: // update
       // å¿½ç•¥ä»£ç 

    case WAIT_OBJECT_0 + 1: // more data
    // è¿™é‡Œå°±æ˜¯ç­‰å¾…å…±äº«å†…å­˜
    DWORD dwWaitAccess = WaitForSingleObject(m_hMutexSharedMemory, INFINITE);
  }
</code></pre>

<p>é€šè¿‡ä¸Šé¢ä»£ç å¯ä»¥çœ‹åˆ°åœ¨ <code class="language-plaintext highlighter-rouge">m_hMutexSharedMemory</code> çš„ä¿¡æ¯ï¼Œå¯ä»¥åœ¨ <code class="language-plaintext highlighter-rouge">m_pSharedMemoryHeader</code> è¯»å–</p>

<pre><code class="language-C++">switch (m_pSharedMemoryHeader-&gt;dwEvent)
{
    case WM_TABLET_PACKET:
    case WM_TABLET_CURSORDOWN:
    case WM_TABLET_CURSORUP:
        *pEvt      = m_pSharedMemoryHeader-&gt;dwEvent;
        *pCursorId = m_pSharedMemoryHeader-&gt;cid;
        *pcPackets = m_pSharedMemoryHeader-&gt;cPackets;
        *pcbPacket = m_pSharedMemoryHeader-&gt;cbPackets / m_pSharedMemoryHeader-&gt;cPackets;
        CHR(EnsurePackets(m_pSharedMemoryHeader-&gt;cbPackets));
        CopyMemory(m_pbPackets, m_pbSharedMemoryPackets, m_pSharedMemoryHeader-&gt;cbPackets);
        *pPackets  = (INT_PTR)m_pbPackets;

#ifdef DELIVERY_PROFILING
        for (INT iPacket = 0; iPacket &lt; *pcPackets; iPacket++)
        {
             INT iOffset = iPacket * (*pcbPacket) / sizeof(LONG);
             switch (m_pSharedMemoryHeader-&gt;dwEvent)
             {
                 case WM_TABLET_PACKET:     ProfilePackets(/*fDown*/FALSE, /*fUp*/FALSE, ((LONG*)m_pbSharedMemoryPackets)[iOffset + 0], ((LONG*)m_pbSharedMemoryPackets)[iOffset + 1]); break;
                 case WM_TABLET_CURSORDOWN: ProfilePackets(/*fDown*/TRUE,  /*fUp*/FALSE, ((LONG*)m_pbSharedMemoryPackets)[iOffset + 0], ((LONG*)m_pbSharedMemoryPackets)[iOffset + 1]); break;
                 case WM_TABLET_CURSORUP:   ProfilePackets(/*fDown*/FALSE, /*fUp*/TRUE,  ((LONG*)m_pbSharedMemoryPackets)[iOffset + 0], ((LONG*)m_pbSharedMemoryPackets)[iOffset + 1]); break;
             }
        }
#endif
        break;

    case WM_TABLET_CURSORINRANGE:
    case WM_TABLET_CURSOROUTOFRANGE:
        *pEvt      = m_pSharedMemoryHeader-&gt;dwEvent;
        *pCursorId = m_pSharedMemoryHeader-&gt;cid;
        *pcPackets = 0;
        *pcbPacket = 0;
        *pPackets  = NULL;
        break;

    case WM_TABLET_SYSTEMEVENT:
        *pEvt      = m_pSharedMemoryHeader-&gt;dwEvent;
        *pCursorId = m_pSharedMemoryHeader-&gt;cid;
        *pcPackets = 0;
        *pcbPacket = 0;
        *pPackets  = NULL;
        m_sysEvt     = m_pSharedMemoryHeader-&gt;sysEvt;
        m_sysEvtData = m_pSharedMemoryHeader-&gt;sysEvtData;
        break;

    default:
        *pEvt      = 0;
        *pCursorId = 0;
        *pcPackets = 0;
        *pcbPacket = 0;
        *pPackets  = NULL;
        break;
}
</code></pre>

<p>å®šä¹‰çš„ä»£ç æ”¾åœ¨ pentypes.h æ–‡ä»¶</p>

<pre><code class="language-C++">#define WM_TABLET_DEFBASE    0x02C0

#define WM_TABLET_CONTEXTCREATE  (WM_TABLET_DEFBASE + 0)
#define WM_TABLET_CONTEXTDESTROY (WM_TABLET_DEFBASE + 1)
#define WM_TABLET_CURSORNEW      (WM_TABLET_DEFBASE + 2)
#define WM_TABLET_CURSORINRANGE  (WM_TABLET_DEFBASE + 3)
#define WM_TABLET_CURSOROUTOFRANGE           (WM_TABLET_DEFBASE + 4)
#define WM_TABLET_CURSORDOWN     (WM_TABLET_DEFBASE + 5)
#define WM_TABLET_CURSORUP       (WM_TABLET_DEFBASE + 6)
#define WM_TABLET_PACKET         (WM_TABLET_DEFBASE + 7)
#define WM_TABLET_ADDED          (WM_TABLET_DEFBASE + 8)
#define WM_TABLET_DELETED        (WM_TABLET_DEFBASE + 9)
#define WM_TABLET_SYSTEMEVENT    (WM_TABLET_DEFBASE + 10)
#define WM_TABLET_MAX            (WM_TABLET_DEFBASE + WM_TABLET_MAXOFFSET)
</code></pre>

<p>è¿™é‡Œçš„ WM_TABLET_CURSORINRANGE æ˜¯ (WM_TABLET_DEFBASE + 3) ä¹Ÿå°±æ˜¯ 707 å¯¹åº”åœ¨ WPF å®šä¹‰çš„ PenEventPenInRange çš„å€¼</p>

<div class="language-csharp highlighter-rouge"><div class="highlight"><pre class="highlight"><code> <span class="k">const</span> <span class="kt">int</span> <span class="n">PenEventPenInRange</span>    <span class="p">=</span> <span class="m">707</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">int</span> <span class="n">PenEventPenOutOfRange</span> <span class="p">=</span> <span class="m">708</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">int</span> <span class="n">PenEventPenDown</span>       <span class="p">=</span> <span class="m">709</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">int</span> <span class="n">PenEventPenUp</span>         <span class="p">=</span> <span class="m">710</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">int</span> <span class="n">PenEventPackets</span>       <span class="p">=</span> <span class="m">711</span><span class="p">;</span>
 <span class="k">const</span> <span class="kt">int</span> <span class="n">PenEventSystem</span>        <span class="p">=</span> <span class="m">714</span><span class="p">;</span>
</code></pre></div></div>

<p>ä¹Ÿå°±æ˜¯ä¸Šé¢çš„ä»£ç å°±æ˜¯æ•´ä¸ªè§¦æ‘¸çš„æ ¸å¿ƒä»£ç </p>

<p>æ›´å¤šä»£ç è¯·çœ‹ <a href="https://github.com/dotnet/wpf/">https://github.com/dotnet/wpf/</a></p>

<p><a href="https://docs.microsoft.com/zh-cn/windows/win32/api/rtscom/nf-rtscom-irealtimestylus-getpacketdescriptiondata?redirectedfrom=MSDN">IRealTimeStylus::GetPacketDescriptionData (rtscom.h) - Win32 apps</a></p>

<p>æ›´å¤šè§¦æ‘¸è¯·çœ‹ <a href="https://blog.lindexi.com/post/WPF-%E8%A7%A6%E6%91%B8%E7%9B%B8%E5%85%B3.html">WPF è§¦æ‘¸ç›¸å…³</a></p>

:ET